<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一文弄不懂MATLAB数据导入</title>
    <link href="/2022/12/12/%E4%B8%80%E6%96%87%E5%BC%84%E6%87%82MATLAB%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5/"/>
    <url>/2022/12/12/%E4%B8%80%E6%96%87%E5%BC%84%E6%87%82MATLAB%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>今天在分析车道保持的训练数据时，想着之前也用过matlab分析过硅电池效率，这次也想着弄个图出来。一看log文件是csv格式，又懒得转成xlsx格式（虽然也就是两三步的事，但我今天还就和它杠上了，我非要用这个csv格式的文件）。 <br><br>之前分析硅电池的时候，用的是<code>xlsread</code>命令导入xlsx文件，现在是csv文件，我先是想到了<code>load</code>命令，后来又再网上搜到了类似的<code>csvread</code>命令和一个我之前没遇到过的<code>importdata</code>命令。索性这次就好好捋一捋不同导入函数之间的爱恨情仇。（只总结了一些我认为比较常用的函数，更为详细的可查看官方文档。如果在之后的学习工作中我用到了其他的函数，我会继续添加上来。） <br></p><h3 id="xlsread命令"><a href="#xlsread命令" class="headerlink" title="xlsread命令"></a><code>xlsread</code>命令</h3><p>将文件变量导入到工作区中，一般<strong>针对电子表格</strong>文件。 <br></p><blockquote><p>由于兼容性问题，不推荐使用这个函数，推荐使用readmatrix函数。 <br></p></blockquote><h3 id="csvread命令"><a href="#csvread命令" class="headerlink" title="csvread命令"></a><code>csvread</code>命令</h3><p>读取逗号分隔值 (CSV) 文件。 <br></p><blockquote><p>由于兼容性问题，不推荐使用这个函数，推荐使用readmatrix函数。 <br></p></blockquote><p>使用命令<code> M = csvread(filename,R1,C1,[R1 C1 R2 C2])</code>，仅读取行偏移量 R1 和 R2 及列偏移量 C1 和 C2 界定的范围。另一种定义范围的方法是使用电子表格表示法（例如 ‘A1..B7’）而非 [0 0 6 1]。 <br><br>说人话：从csv文件中的第R1行开始读取到第R2行，第C1列开始读取到第C2列。例如： <br><br>存在csv文件： <br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csv">02, 04, 06, 08<br>03, 06, 09, 12<br>05, 10, 15, 20<br>07, 14, 21, 28<br></code></pre></td></tr></table></figure><p>使用命令： <br></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">filename = <span class="hljs-string">&#x27;csvlist.csv&#x27;</span>;<br>M = csvread(filename)；<br>M = csvread(<span class="hljs-string">&#x27;csvlist.csv&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]);<br>M =<br><br>     <span class="hljs-number">3</span>     <span class="hljs-number">6</span>     <span class="hljs-number">9</span><br>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>    <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><blockquote><p>注意： <br></p></blockquote><ul><li>与matlab数组下标从1开始不同，偏移量 R1&#x3D;0、C1&#x3D;0 指定文件中的第一个值。 <br></li><li>我们可以使用<strong>电子表格表示法</strong>（例如 ‘A2..C3’）而非 [1 0 2 2]来指定读取范围。 <br></li></ul><h3 id="readmatrix命令"><a href="#readmatrix命令" class="headerlink" title="readmatrix命令"></a><code>readmatrix</code>命令</h3><p>readmatrix功能非常强大，可以从文件中读取矩阵。非常适合于以下两种文件： <br></p><ul><li>.txt、.dat 或 .csv（带分隔符的文本文件）</li><li>.xls、.xlsb、.xlsm、.xlsx、.xltm、.xltx 或 .ods（电子表格文件）</li></ul><h4 id="A-readmatrix-filename"><a href="#A-readmatrix-filename" class="headerlink" title="A = readmatrix(filename)"></a><code>A = readmatrix(filename)</code></h4><p>使用命令<code>M = readmatrix(&#39;basic_matrix.xlsx&#39;)</code>将电子表格文件中的数值数据导入为矩阵，并命名为M。 <br></p><h4 id="A-readmatrix-filename-opts"><a href="#A-readmatrix-filename-opts" class="headerlink" title="A = readmatrix(filename,opts)"></a><code>A = readmatrix(filename,opts)</code></h4><p>通过配置opts参数，可以使得在导入数据的时候满足更多个性化需求。 <br><br>例如，假如我有一个电子表格文件 airlinesmall_subset.xlsx 包含 1996 年至 2008 年间多个工作表中的数据。每个工作表都包含给定年份的数据。使用命令： <br></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">opts.Sheet = <span class="hljs-string">&#x27;2007&#x27;</span>;    <span class="hljs-comment">%指定读取名称为‘2007’的工作表中的数据</span><br>opts.SelectedVariableNames = [<span class="hljs-number">1</span>:<span class="hljs-number">5</span>];     <span class="hljs-comment">%指定读取第1列到第5列的变量</span><br>opts.DataRange = <span class="hljs-string">&#x27;2:11&#x27;</span>;    <span class="hljs-comment">%指定读取第2行到第11行的数据</span><br>M = readmatrix(<span class="hljs-string">&#x27;airlinesmall_subset.xlsx&#x27;</span>,opts)<br><span class="hljs-comment">%相当于使用命令：M = readmatrix(&#x27;airlinesmall_subset.xlsx&#x27;,&#x27;Sheet&#x27;,&#x27;2007&#x27;,&#x27;Range&#x27;,&#x27;A2:E11&#x27;)</span><br></code></pre></td></tr></table></figure><h3 id="imread命令"><a href="#imread命令" class="headerlink" title="imread命令"></a><code>imread</code>命令</h3><p>从<strong>图形文件</strong>读取图像。</p><h4 id="A-imread-filename"><a href="#A-imread-filename" class="headerlink" title=" A = imread(filename)"></a><code> A = imread(filename)</code></h4><p>从 filename 指定的文件读取图像，并从文件内容推断出其格式。如果 filename 为多图像文件，则 imread 读取该文件中的第一个图像。 <br></p><h3 id="audioread命令（暂定）"><a href="#audioread命令（暂定）" class="headerlink" title="audioread命令（暂定）"></a><code>audioread</code>命令（暂定）</h3><p>将文件变量导入到工作区中，一般<strong>针对音频</strong>文件</p><h3 id="load命令"><a href="#load命令" class="headerlink" title="load命令"></a><code>load</code>命令</h3><p>将文件变量导入到工作区中，一般<strong>针对matlab特有的格式文件</strong>，即 .mat文件。 <br><br>注意：<strong>load 命令在初始化变量时可能会执行 MAT 文件中包含的代码。请避免对不受信任的 MAT 文件调用 load</strong> <br></p><h4 id="load-filename"><a href="#load-filename" class="headerlink" title="load(filename)"></a><code>load(filename)</code></h4><p>使用命令： <br></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A = load(filename)       <span class="hljs-comment">%filename可以是.mat文件，也可以是ASCII文件（也叫文本文件即.txt文件）</span><br></code></pre></td></tr></table></figure><blockquote><p>注：ASCII文件指含有用标准ASCII字符集编码的字符的数据和文本文件，只含有字母、数字和常见的符号。这种文件在磁盘中存放时每个字符对应一个8bits的字节，用于存放对应的ASCII码。区别于按二进制的编码方式来存放文件的二进制文件。</p></blockquote><ul><li>如果 filename 是 MAT 文件，则load(filename) 会将 MAT 文件中的变量加载到 MATLAB® 工作区，A是结构数组。</li><li>如果 filename 是 ASCII 文件，load(filename) 会创建一个包含该文件数据的双精度数组。 <br><br>我们还可以通过下面两条命令来指定导入的文件类型，而不管文件拓展名是什么： <br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A = load(<span class="hljs-number">123.</span>mat, ‘-ascii’)   <span class="hljs-comment">%尽管文件后缀为mat格式，我们仍将其作为ascii文件导入</span><br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A = load(<span class="hljs-number">456.</span>txt, ‘-mat’)   <span class="hljs-comment">%尽管文件后缀为txt格式，我们仍将其作为mat文件导入</span><br></code></pre></td></tr></table></figure><blockquote><p>注：<strong>load函数的命令形式</strong>，使用命令’load filename’，省去了括号和文件名字符串外面的引号，除此之外我也不知道为什么要创造这个命令形式。 <br></p></blockquote></li></ul><h3 id="importdata命令"><a href="#importdata命令" class="headerlink" title="importdata命令"></a><code>importdata</code>命令</h3><p>将数据导入到工作区中，可以导入各种类型的数据（如图片数据、数字、字符串等）、系统剪切板的数据等，函数的输入参数<code>delimiterIn</code>、<code>headerlinesIn</code>表示文件中的数据分隔符、以及我想从哪一行数据开始导入。 <br><br>附[mathworks官方importdata说明文档] (<a href="https://ww2.mathworks.cn/help/matlab/ref/importdata.html#btldf1f-1">https://ww2.mathworks.cn/help/matlab/ref/importdata.html#btldf1f-1</a>) <br><br><img src="/img/article/art4/pic1.png" alt="pic1"></p><h4 id="importdata-filename-delimiterIn-headerlinesIn"><a href="#importdata-filename-delimiterIn-headerlinesIn" class="headerlink" title="importdata(filename,delimiterIn,headerlinesIn)"></a><code>importdata(filename,delimiterIn,headerlinesIn)</code></h4><p>说人话：使用参数<code>delimiterIn</code>告诉matlab我们文件中的数据分隔符是什么。使用参数<code>headerlinesIn</code>告诉matlab我想从哪里开始导入数据。如： <br><br>我们使用文本编辑器创建一个带有列标题的称为 myfile01.txt 的空格分隔 ASCII 文件。 <br></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">Day1  Day2  Day3  Day4  Day5  Day6  Day7<br>95.01 76.21 61.54 40.57  5.79 20.28  1.53<br>23.11 45.65 79.19 93.55 35.29 19.87 74.68<br>60.68  1.85 92.18 91.69 81.32 60.38 44.51<br>48.60 82.14 73.82 41.03  0.99 27.22 93.18<br>89.13 44.47 17.63 89.36 13.89 19.88 46.60<br></code></pre></td></tr></table></figure><p>输入以下命令： <br></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">filename = <span class="hljs-string">&#x27;myfile01.txt&#x27;</span>;<br>delimiterIn = <span class="hljs-string">&#x27; &#x27;</span>;<br>headerlinesIn = <span class="hljs-number">1</span>;<br>A = importdata(filename,delimiterIn,headerlinesIn);<br><span class="hljs-comment">% 也就是A = importdata(‘myfile01.txt’, ‘ ’, 1);</span><br><span class="hljs-comment">% 注意，第二个单引号内存在一个空格</span><br></code></pre></td></tr></table></figure><p>上面的命令告诉我们，我们要导入一个叫做’myfile01.txt’的文本文件，它是以空格作为分隔符，并且我们导入从<strong>headerlinesIn +1</strong>&#x3D;2行开始的<strong>数值数据</strong>。 <br><br>获得一个结构体输出：<br><br><img src="/img/article/art4/pic2.png" alt="pic2"><br>导出了从第headerlinesIn +1即第二行开始的数值数据作为struct中的data，第headerlinesIn行作为colheaders，第一行到第headerlinesIn行的数据作为textdata。在缺省headerlinesIn参数的情况下importdata 函数将会在文件中检测该值。 <br></p><h4 id="A-delimiterOut-headerlinesOut-importdata"><a href="#A-delimiterOut-headerlinesOut-importdata" class="headerlink" title="[A,delimiterOut,headerlinesOut] = importdata(___)"></a><code>[A,delimiterOut,headerlinesOut] = importdata(___)</code></h4><p>在<code>delimiterOut</code>中额外返回检测到的输入 ASCII 文件中的分隔符，以及在<code>headerlinesOut</code>中返回检测到的标题行数。 <br></p><h4 id="A-importdata-39-pastespecial-39"><a href="#A-importdata-39-pastespecial-39" class="headerlink" title="A = importdata(&#39;-pastespecial&#39;)"></a><code>A = importdata(&#39;-pastespecial&#39;)</code></h4><p>将系统剪切板上的数据导入给A变量，这个数据不能是图片，因为系统剪切板复制的图片并没有存储在当前目录中。</p><h3 id="uiimport命令（暂定）"><a href="#uiimport命令（暂定）" class="headerlink" title="uiimport命令（暂定）"></a><code>uiimport</code>命令（暂定）</h3>]]></content>
    
    
    
    <tags>
      
      <tag>MATLAB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录今日破防</title>
    <link href="/2022/12/07/%E8%AE%B0%E5%BD%95%E4%BB%8A%E6%97%A5%E7%A0%B4%E9%98%B2/"/>
    <url>/2022/12/07/%E8%AE%B0%E5%BD%95%E4%BB%8A%E6%97%A5%E7%A0%B4%E9%98%B2/</url>
    
    <content type="html"><![CDATA[<p>在将添加的两篇测试文章“text”、“text2”删除后，重新生成并部署网站后，发现文章依旧在网站端页面显示，我就意识到了事情的不简单。<br>之所以添加这两篇测试文章，是因为我发现我新提交的文章“构建笔记系统”无法在页面显示，于是我就重新提交了两篇测试文章，发现每新提交一篇文章，网页上就会显示上一次提交的文章，这让我很疑惑。<br><img src="/img/article/art3/p1.png" alt="pic1"><br><img src="/img/article/art3/p2.png" alt="pic2"><br>我首先留意到了这样一段warning: <br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">warning: <span class="hljs-keyword">in</span> the working copy of <span class="hljs-string">&#x27;archives/2022/12/index.html&#x27;</span>, LF will be replaced by CRLF the next time Git touches it<br></code></pre></td></tr></table></figure><p>在google后了解到，这是由于在跨平台操作下CR(CarriageReturn：回车，\r)与LF(LineFeed：换行，\n)可能会产生冲突。详参考博文<a href="https://blog.csdn.net/u012757419/article/details/105614028">git提示“warning: LF will be replaced by CRLF”的解决办法_青崖林夕的博客-CSDN博客</a>，此处不再赘述。由于我日常主力还是在Windows上进行，还是默认设置Git在提交时自动把回车（CR）和换行（LF）转换成换行（LF）。使用命令: <br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#提交时转换为LF，检出时不转换</span><br>$ git config --global core.autocrlf <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>但我在提交新文章的时候仍然会产生这个warning，，， <br><br>然后我又输入了这样一条命令： <br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#提交时转换为LF，检出时不转换</span><br>$ git config core.autocrlf<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>再提交就不报warning了，很玄啊，<del>感觉在玩一种很新的东西</del><br><br>解决了这个warning，我闲着无事又刷新了网页，发现博客界面恢复正常了,给我整无语了。<br><br><img src="/img/article/art3/p3.png" alt="pic3"></p><p>原来是从部署后到直接在页面显示出结果会有一定的延时，稍微等待一会就OK了，焯！建议大家以后提交博客后不要着急使用<code>hexo d</code>部署网站，先使用<code>hexo s</code>启用服务预览看一看页面是否正常后再部署，然后稍微<strong>耐心等待</strong>一会。<br><br>好了，折腾了将近两个小时，整了这么一出闹剧，下午还得复习复习半导体器件，估计明天就期中考试了。<br><br>啥都不会，救，，，</p>]]></content>
    
    
    
    <tags>
      
      <tag>网页部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建笔记系统</title>
    <link href="/2022/12/06/%E6%9E%84%E5%BB%BA%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/12/06/%E6%9E%84%E5%BB%BA%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>此文章是对B站UP主田浅浅发布的<a href="https://www.bilibili.com/video/BV12N4y1c7KW/?spm_id_from=333.1007.top_right_bar_window_history.content.click">构建笔记系统</a>的一些整理，方便以后回顾。</p><h2 id="笔记的功能"><a href="#笔记的功能" class="headerlink" title="笔记的功能"></a>笔记的功能</h2><p>以不同的应用场景为例，涉及到笔记不同的功能：<strong>记录功能</strong>、<strong>理解功能</strong>、<strong>压缩功能</strong>。记住，学习的最终目的是让知识进入到脑子里不，是写给别人看的，可以不用太过追求美观。<br></p><h3 id="记录功能（求全面）"><a href="#记录功能（求全面）" class="headerlink" title="记录功能（求全面）"></a>记录功能（求全面）</h3><p>在听讲座时，时间紧张，以扎住关键信息为主，体现以<strong>收集信息</strong>为目的的记录功能。<br></p><h3 id="理解功能（读清晰）"><a href="#理解功能（读清晰）" class="headerlink" title="理解功能（读清晰）"></a>理解功能（读清晰）</h3><p>在阅读教材时，体现以<strong>整理加工信息</strong>为目的的理解功能，不要浪费时间抄书本上已有的信息。只有书上没有，需要补充的信息如新的发现、科技创新或将几本书籍的内容整合在一起时。可单独建立一个文档或一个笔记本，把不同来源的资料归一整合。<br><br>处理加工已经收集到的信息，变成自己能够理解的东西，分为两个步骤：<br></p><h4 id="信息管理"><a href="#信息管理" class="headerlink" title="信息管理"></a>信息管理</h4><p>找出不同段落之间的内在联系，是宏观上的信息管理；找出不同句子和词之间的联系，是微观上的信息管理。</p><h4 id="知识管理"><a href="#知识管理" class="headerlink" title="知识管理"></a>知识管理</h4><p>它表征了我们学习时对知识的掌握程度。将接触到的知识<strong>进行分类</strong>如：重点，难点，是否掌握，是否牢固，是否需要针对性做题复习等等。<br><br>可使用不同颜色标注，示例：<br><br><font color = #66FF66 size=5 face="宋体">【难点+没懂】!!!</font> 意思是这里很难并且我还没弄懂。 <br><br><font color = #ff0000 size=5 face="宋体">【难点+懂了】难句子</font> 意思是这个地方虽然很难，但我已经掌握了，只需要稍后去复习。 <br><br><font color = #66ccff size=5 face="宋体">【重点、概括性】句子</font> 很重要，需要加强理解。 <br><br><font color = #ffd700 size=5 face="宋体">【重要概念】名词</font> 标注一些重要的名词。 <br></p><h3 id="压缩功能（厚书读薄）"><a href="#压缩功能（厚书读薄）" class="headerlink" title="压缩功能（厚书读薄）"></a>压缩功能（厚书读薄）</h3><p><strong>建立在理解和记忆的基础上</strong>，把信息概括成一个一个的组块，关键在于把句子压缩到<strong>尽可能简洁</strong><br><br>由于大脑容量有限，无法准确记忆每一个句子，我们可以使用关键词概括一整段的资料。极度压缩信息，比如思维导图，形成一个完整的框架。复习时大脑进行知识闪回，知识流扩散，重组。<br><br>可以记在笔记本上，亦可以直接写在书本上（如政治课）。这一步可以用一些速记符号，记忆口诀、联想法和记忆迷宫等方式</p><h3 id="检测功能（知识入脑）"><a href="#检测功能（知识入脑）" class="headerlink" title="检测功能（知识入脑）"></a>检测功能（知识入脑）</h3><p>学习的目的是记忆、掌握知识，笔记就是用来复习检验，确保真正记忆理解了信息。<br><br>利用第三步压缩的框架，回忆整个知识点。当你把整个框架都从单个的概括压缩性的词还原成书本上的文段和句子后，进行<strong>查漏补缺</strong>，并做好对应的标记。</p><p><strong>一句话概括：理解→化繁为简→记忆→化简为繁→查漏补缺。把书从厚读薄，再从薄读厚</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>涉猎集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>序章</title>
    <link href="/2022/12/05/hello-world/"/>
    <url>/2022/12/05/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>GitHub IO, <strong>我来啦!</strong><br>折腾了一天，终于搭建好了属于自己的博客！<br><br><del>以后就可以在这个小窝安心地生产垃圾啦</del><br><br>咳咳，我要记录想法、学习心得以供将来参考<del>顺便有事没事倾诉一下苦水、发发牢骚</del><br></p><h2 id="小小记录一下几个命令"><a href="#小小记录一下几个命令" class="headerlink" title="小小记录一下几个命令"></a>小小记录一下几个命令</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server / 常简写为hexo s<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate / 常简写为hexo g<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy / 常简写为hexo g<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>遐想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

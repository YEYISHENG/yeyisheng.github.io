<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MATLAB求解函数最值</title>
    <link href="/2024/03/06/MATLAB%E6%B1%82%E8%A7%A3%E5%87%BD%E6%95%B0%E6%9C%80%E5%80%BC/"/>
    <url>/2024/03/06/MATLAB%E6%B1%82%E8%A7%A3%E5%87%BD%E6%95%B0%E6%9C%80%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>如图，第一问在求解抽样信号的量化编码时，首先要将抽样信号幅值用信号最大幅值归一化。答案公式使用了I_s=，但明眼人一看就感觉f(t)的幅值不是10V。虽然说我理解在这里使用10V作为输入信号幅值是为了简化运算，但本着爱钻牛角尖精益求精的精神，我想着求一下f(t)的幅值。（我是真的闲啊，是不是忘了明天考嵌入式，再过一周考数字信号处理和通信原理？）对于f(t)=，，，，，显然直接求导找驻点，然后代入验证极值就可以得到最值，但我不想手算，直接上MATLAB，谁叫它是宇宙第一（maybe？）数学工具呢。先绘个图，探探虚实 、、、matlab syms x y =10<em>sin(4</em>pi<em>x)+sin(8</em>pi<em>x); y1 =10</em>sin(4<em>pi</em>x); y2 = sin(8<em>pi</em>x); fplot(y); holdon;fplot(y1); hold on ;fplot(y2); 、、、</p>]]></content>
    
    
    
    <tags>
      
      <tag>函数方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乘法器优化——Booth编码的奥秘</title>
    <link href="/2023/01/14/%E4%B9%98%E6%B3%95%E5%99%A8%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94Booth%E7%BC%96%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/"/>
    <url>/2023/01/14/%E4%B9%98%E6%B3%95%E5%99%A8%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94Booth%E7%BC%96%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/</url>
    
    <content type="html"><![CDATA[<h2 id="引子乘法器概论">引子：乘法器概论</h2><p>在整个数字集成电路的世界里，乘法器的速度优化是一个亘古不变的话题，因为乘法器是高性能微处理器中的关键部件，是进行高速计算特别是信号处理等方面应用时所必须的。对于现今普遍采用的阵列乘法器（arraymultiplier），它囊括了以下三个功能：产生部分积、累积部分积与最终相加，所以在进行乘法器速度优化时，我们可以从以下三个方面考虑：<br> - 加快部分积的产生 - 减少部分积的数 - 加速部分积的加法操作</p><figure><img src="/img/article/art5/1.png" alt="图 1 二进制阵列乘法器" /><figcaption aria-hidden="true">图 1 二进制阵列乘法器</figcaption></figure><p>本文主要在查阅有关资料的基础上，整理了<strong>布斯编码</strong>（BoothEncoding一种用来减少部分积数目的算法）与在此基础上提出的<strong>改进布斯编码</strong>（modifiedBooth’sencoding）的相关知识，并结合自己的理解，使用通俗易懂的语言进行阐述。<br></p><h2 id="booth编码">Booth编码</h2><h3 id="wikipedia定义">Wikipedia定义</h3><p>布斯编码可以减少部分积的数目，用来计算有符号乘法，提高乘法运算的速度。对于Booth编码，维基百科是这么说的：<br><img src="/img/article/art5/2.png" alt="图 2 Wikipedia定义" />这段详解已经胜过国内大多数教材的介绍，但相信这一大串数学符号也会劝退很多人，本文的目的就是通俗易懂，让小白也能看懂Booth编码。所以我又查阅资料，重新进行整理。<br> 锵！且听我娓娓道来~ <br></p><h3 id="工作原理">工作原理</h3><p>我们知道，乘法计算本质上就是加法运算，但当乘数中二进制1数量过多时，会出现大量繁杂的加法运算，而二进制0的存在可以降低运算次数，因为0和任何数相乘都为0，我们就无需再进行计算，就像下图中这样：<br> <img src="/img/article/art5/3.png" alt="图 3 简单乘法操作" /> <imgsrc="/img/article/art5/4.png" alt="图 4 繁杂乘法操作" />可以看出，相较于图4，图3中的计算由于乘数中0的个数较多，使得计算大大简化。<br>那么问题来了，是否存在这样一种编码方式，能够大大缩减乘数中二进制1的个数，进而简化运算？答案是肯定的，也就是我们将要介绍的Booth编码。<br> 其实早在小学时代，我们就学过这样的简便运算： <br> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">9x99=9x(100-1)=900-9=891<br></code></pre></td></tr></table></figure>将乘数“99”化为“100-1”，计算更为简单。类似的，在二进制补码乘法X<em>Y中，我们也可以采取相同的操作。对于乘数:<br> <span class="math display">\[Y=[0111\_1110]_补=2^6+2^5+2^4+2^3+2^2+2^1\]</span><br />我们采用另外一种相对简单的表示方式： <br> <span class="math display">\[[0111\_1110]_补=[1000\_0000]_补-[0000\_0010]_补，将其记为[1000\_00\overline10]（这里的\overline1是-1的缩写符号）\]</span> 此时X</em>Y可以表示为： <br> <span class="math display">\[X*Y=X*[0111\_1110]_补=X*([1000\_0000]_补-[0000\_0010]_补)=X*[1000\_0000]_补-X*[0000\_0010]_补\]</span> <br>采用这一形式，我们只需相加两个部分积（但这要求最终设计的加法器必须也能执行减法，否则需将减法-[0000_0010]补转换成补码加法+[1111_1110]补，这又会产生七个部分积，得不偿失）。这种形式的变换称为布斯编码（BoothEncode），它使部分积的数目至少可以缩减到原来的一半。部分积的减少意味着相加次数的减少，从而加快了运算速度并减少了面积。<br></p><h3 id="补码一位乘法">补码一位乘法</h3><p>下面先简要阐述Booth算法的基本流程： <br> 设<spanclass="math display">\[[X]_补=x_s·x_1·x_2···x_n,[Y]_补=y_s·y_1·y_2···y_n\]</span>其中<spanclass="math inline">\(x_s,y_s\)</span>均为符号位将符号位参与计算，运算数以补码表示且被乘数与部分积都取双符号位。<br> -被乘数和部分积均取两位符号位即变形码，乘数取一位符号位，并参与运算 -乘数末尾增设附加位<span class="math inline">\(Y_{n+1}\)</span>，其初始值为0。 <span class="math inline">\(Y_n\)</span>和<spanclass="math inline">\(Y_{n+1}\)</span>构成各步运算的乘数判断位，按表所示方法进行操作-按补码移位规则：部分积为正(第一符号位为0)，右移时有效位最高位补0；部分积为负，右移时有效位最高位补1- 按Booth乘法表算法进行到第n+1步，但第n+1步的部分积不再移位</p><table align="center" border="2"><thead><tr><th colspan="4">Booth乘法表</th></tr></thead><tbody><tr><td>乘数位</td><td>编码位</td></tr><tr><td>00</td><td>0</td></tr><tr><td>01</td><td>+被乘数</td></tr><tr><td>10</td><td>-被乘数</td></tr><tr><td>11</td><td>0</td></tr></tbody></table><p>下面给出一个示例： <br> 设机器字长为5位，其中一位是符号位。且：<spanclass="math inline">\([X]_补=1.0101,[Y]_补=1.0011\)</span> <br> <imgsrc="/img/article/art5/5.png" alt="图 5 Booth乘法操作" /></p><h3 id="数学推导">数学推导</h3><p>对于只想浅探Booth编码的定义及工作原理的朋友，上述内容已足够清晰明了。但考虑到严谨性与实际应用，该部分给出部分数学上的推导以及更为详尽的说明。<br> 前面已经提到将乘数<spanclass="math inline">\(Y=[0111\_1110]_补\)</span>表示为<spanclass="math inline">\([1000\_00\overline10]\)</span>，这个转换不是一眼看出来的，怎样将其进行推广，使我们能够对任意的乘数都能进行类似的转换以化简运算呢？<br> 考虑有符号乘数： <span class="math display">\[Y=[y_{n-1}y_{n-2}···y_1y_0]_2\]</span></p><p><font color = #000000 size=2 face="宋体"><spanclass="math inline">\(Y=[y_{n-1}y_{n-2}···y_1y_0]_2\)</span></font> <br><font color = #000000 size=2 face="宋体"><spanclass="math inline">\((1)=-2^{n-1}·y_{n-1}+2^{n-2}·y_{n-2}+···+2^1·y_1+2^0·y_0+y_{-1}\)</span></font><br> <font color = #339933 size=2 face="宋体"><spanclass="math inline">\((2)=2^{n-1}·(y_{n-2}-y_{n-1})+2^{n-2}·(y_{n-3}-y_{n-2})+···+2^0·(y_{-1}-y_0)\)</span></font><br> <font color = #ff0000 size=2 face="宋体"><spanclass="math inline">\((3)=2^{n-2}·(y_{n-2}+y_{n-3}-2·y_{n-1})+2^{n-4}·(y_{n-4}+y_{n-5}-2·y_{n-3})+···+2^{0}·(y_{0}+y_{-1}-2·y_{1})\)</span></font><br> <font color = #ff0000 size=2 face="宋体"><spanclass="math inline">\((4)=\sum_{i=0}^{(N-1)/2}Y_i·4^i,(Y \in\{-2,-1,0,1,2\})\)</span></font> <br></p><p>定义<spanclass="math inline">\(Y_i=y_{i-2}-y_{i-1}\)</span>，考虑(2)式，对于二进制数<spanclass="math inline">\(Y,y_i \in \{0,1\}\)</span> ，从(2)式中可以看出：<br> <span class="math display">\[\left\{\begin{aligned}if &amp; &amp; y_{i+1}=y_i, &amp; &amp; then &amp; &amp; Y_i=0, \\if &amp; &amp; y_{i+1}&gt;y_i, &amp; &amp; then &amp; &amp; Y_i=1, \\if &amp; &amp; y_{i+1}&lt;y_i, &amp; &amp; then &amp; &amp; Y_i=-1.\end{aligned}\right.\]</span> 这构成了Booth编码的部分积选择表。 <br></p><table align="center" border="2"><thead><tr><th colspan="4">Booth乘法表</th></tr></thead><tbody><tr><td>乘数位</td><td>编码位</td></tr><tr><td>00</td><td>0</td></tr><tr><td>01</td><td>+被乘数</td></tr><tr><td>10</td><td>-被乘数</td></tr><tr><td>11</td><td>0</td></tr></tbody></table><p>定义<spanclass="math inline">\(Y_i=y_{i-2}+y_{i-3}-2·y_{n-1}\)</span>，考虑(3)式，对于二进制数<spanclass="math inline">\(Y,y_i \in \{0,1\}\)</span> ，从(3)式中可以看出：<br> <span class="math display">\[\left\{\begin{aligned}if &amp; &amp; y_{2i+1}=0 &amp; &amp; and &amp; &amp; y_{2i}+y_{2i-1}=0,&amp; &amp; then &amp; &amp; Y_i=0,  \\if &amp; &amp; y_{2i+1}=0 &amp; &amp; and &amp; &amp; y_{2i}+y_{2i-1}=1,&amp; &amp; then &amp; &amp; Y_i=1,  \\if &amp; &amp; y_{2i+1}=0 &amp; &amp; and &amp; &amp; y_{2i}+y_{2i-1}=2,&amp; &amp; then &amp; &amp; Y_i=2,  \\if &amp; &amp; y_{2i+1}=1 &amp; &amp; and &amp; &amp; y_{2i}+y_{2i-1}=0,&amp; &amp; then &amp; &amp; Y_i=-2, \\if &amp; &amp; y_{2i+1}=1 &amp; &amp; and &amp; &amp; y_{2i}+y_{2i-1}=1,&amp; &amp; then &amp; &amp; Y_i=-1, \\if &amp; &amp; y_{2i+1}=1 &amp; &amp; and &amp; &amp; y_{2i}+y_{2i-1}=2,&amp; &amp; then &amp; &amp; Y_i=0.\end{aligned}\right.\]</span> 这构成了改进Booth编码的部分积选择表。 <br></p><table align="center" border="2"><thead><tr><th colspan="4">改进Booth乘法表</th></tr></thead><tbody><tr><td>乘数位</td><td>编码位</td></tr><tr><td>000</td><td>0</td></tr><tr><td>001</td><td>+被乘数</td></tr><tr><td>010</td><td>+被乘数</td></tr><tr><td>011</td><td>+2×被乘数</td></tr><tr><td>100</td><td>-2×被乘数</td></tr><tr><td>101</td><td>-被乘数</td></tr><tr><td>110</td><td>-被乘数</td></tr><tr><td>111</td><td>0</td></tr></tbody></table><p>同时，我们还从（4）中看出，改进的Booth编码相当于把乘数变换为一个四进制形式，而不是通常的二进制形式。<br></p><p>读者在这里可能会有些疑惑：为什么已有了Booth编码，还要研究一个改进的Booth编码？<br></p><p>这是因为，如果使用Booth编码，乘数经编码后含二进制1的数量是不确定的，这会导致产生不确定的部分积数目，<em>在最坏情况下，一个8位的乘数经Booth编码后将含有4个部分积</em><br></p><p>考虑8位乘数在最坏情况下的输入：8位乘数1010_1010，经Booth编码后为<spanclass="math inline">\(\overline11\overline11\_\overline11\overline10=[0101\_0100]_补-[1010\_1010]_补\)</span>，Rabaey书上原文的说法是:<br></p><blockquote><p>“1010…10代表了最坏情况的乘数输入，因为它产生的部分积数目最多（为一半）”</p></blockquote><p>在这个例子中体现为减数<spanclass="math inline">\([1010\_1010]_补\)</span>在乘法运算时将会产生4个部分积。这里我有一点疑惑，按理说在乘法运算时将会产生7个部分积，被减数<spanclass="math inline">\([0101\_0100]_补\)</span>将会产生3个部分积，减数<spanclass="math inline">\([1010\_1010]_补\)</span>将会产生4个部分积。暂时保留这个疑惑，不求甚解了哈哈。<br></p><p>大小不同的部分积阵列对乘法器设计不合适，改进的Booth编码可以解决这个问题，正因如此，我们最常使用的是改进的Booth编码。<br></p><p>使用改进的Booth编码，乘数按三位一组进行划分，并相互重叠一位，每一组的三位按表改进的Booth编码表进行划分，（首先将乘数两两划分一组，那么编码的三位分别由当前组的两位加相邻低位组的最高位组成），编码过程由msb至lsb进行，编码后所形成的的部分积的数目等于乘数宽度的一半，是一个确定的数目。<br></p><p>最后给出一个改进Booth编码的示例： <br></p><blockquote><p>考虑前面提及的8位二进制数<spanclass="math inline">\([0111\_1110]_补\)</span>，按照改进Booth编码规则进行转换。首先将其两两划分一组，共分为四组：<spanclass="math inline">\(01、11、11、10\)</span>。接着将当前组的两位与相邻低位组的最高位进行组合，分为这样四组：<spanclass="math inline">\(011、111、111、100\)</span>，其中最后一组多出来的是附加位0。最后根据表11.2编码得到<spanclass="math inline">\(10(2×)、00(0×)、00(0×)、\overline10(-2×)\)</span>，组合在一起表示为<spanclass="math inline">\(1000\_00\overline10\)</span>.这与前面采用Booth编码得到的结果是一致的。</p></blockquote><h2 id="小结">小结</h2><p>本文通过对乘法器的速度优化进行引入，以通俗易懂的语言，介绍了Booth编码及在此基础上提出的改进Booth编码的原理与示例。<br></p><h2 id="后话">后话</h2><p>Booth编码是在本人学习计组、数集和硬件描述语言课程中反复碰到的一个概念，由于课程不做要求，一直没有太重视。但在数集的大作业中，其中一个选题又要求我们设计一个基于Booth编码的乘法器，虽然我没选这个（bushi）。因此我想要彻底弄懂这个概念，先后看了计组老师的PPT，啃了半天Rabaey的那本“圣经”，只觉头昏脑涨，查了很多资料才只敢说有一些浅显的了解，查阅资料加整理成markdown发布前后共耗费三天时间（markdown功底太差了，还得多练练）。由于本人能力与精力有限，文章难免存在错误与疏漏，大家还是有选择的阅读。<br></p><h2 id="参考文献">参考文献</h2><p>[1].维基百科 <br> [2].Rabaey. 数字集成电路——电路、系统与设计 <br>[3].<a href="https://www.zhihu.com/question/37637775">怎么理解Booth算法?- 知乎 (zhihu.com)</a> <br> [4].计组课程PPT 定点原码-补码乘法器</p>]]></content>
    
    
    
    <tags>
      
      <tag>乘法器优化</tag>
      
      <tag>Booth编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文弄不懂MATLAB数据导入</title>
    <link href="/2022/12/12/%E4%B8%80%E6%96%87%E5%BC%84%E4%B8%8D%E6%87%82MATLAB%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5/"/>
    <url>/2022/12/12/%E4%B8%80%E6%96%87%E5%BC%84%E4%B8%8D%E6%87%82MATLAB%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="引子">引子</h3><p>今天在分析车道保持的训练数据时，想着之前也用过matlab分析过硅电池效率，这次也想着弄个图出来。一看log文件是csv格式，又懒得转成xlsx格式（虽然也就是两三步的事，但我今天还就和它杠上了，我非要用这个csv格式的文件）。<br>之前分析硅电池的时候，用的是<code>xlsread</code>命令导入xlsx文件，现在是csv文件，我先是想到了<code>load</code>命令，后来又再网上搜到了类似的<code>csvread</code>命令和一个我之前没遇到过的<code>importdata</code>命令。索性这次就好好捋一捋不同导入函数之间的爱恨情仇。（只总结了一些我认为比较常用的函数，更为详细的可查看官方文档。如果在之后的学习工作中我用到了其他的函数，我会继续添加上来。）<br> ### <code>xlsread</code>命令将文件变量导入到工作区中，一般<strong>针对电子表格</strong>文件。 <br>&gt; 由于兼容性问题，不推荐使用这个函数，推荐使用readmatrix函数。<br></p><h3 id="csvread命令"><code>csvread</code>命令</h3><p>读取逗号分隔值 (CSV) 文件。 <br> &gt;由于兼容性问题，不推荐使用这个函数，推荐使用readmatrix函数。 <br></p><p>使用命令<code>M = csvread(filename,R1,C1,[R1 C1 R2 C2])</code>，仅读取行偏移量R1 和 R2 及列偏移量 C1 和 C2界定的范围。另一种定义范围的方法是使用电子表格表示法（例如'A1..B7'）而非 [0 0 6 1]。 <br>说人话：从csv文件中的第R1行开始读取到第R2行，第C1列开始读取到第C2列。例如：<br> 存在csv文件： <br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csv">02, 04, 06, 08<br>03, 06, 09, 12<br>05, 10, 15, 20<br>07, 14, 21, 28<br></code></pre></td></tr></table></figure> 使用命令： <br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">filename = <span class="hljs-string">&#x27;csvlist.csv&#x27;</span>;<br>M = csvread(filename)；<br>M = csvread(<span class="hljs-string">&#x27;csvlist.csv&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]);<br>M =<br><br>     <span class="hljs-number">3</span>     <span class="hljs-number">6</span>     <span class="hljs-number">9</span><br>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>    <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure> &gt;注意： <br> - 与matlab数组下标从1开始不同，偏移量 R1=0、C1=0指定文件中的第一个值。 <br> -我们可以使用<strong>电子表格表示法</strong>（例如 'A2..C3'）而非 [1 0 22]来指定读取范围。 <br></p><h3 id="readmatrix命令"><code>readmatrix</code>命令</h3><p>readmatrix功能非常强大，可以从文件中读取矩阵。非常适合于以下两种文件：<br> - .txt、.dat 或 .csv（带分隔符的文本文件） -.xls、.xlsb、.xlsm、.xlsx、.xltm、.xltx 或 .ods（电子表格文件）</p><h4 id="a-readmatrixfilename"><code>A = readmatrix(filename)</code></h4><p>使用命令<code>M = readmatrix('basic_matrix.xlsx')</code>将电子表格文件中的数值数据导入为矩阵，并命名为M。<br></p><h4id="a-readmatrixfilenameopts"><code>A = readmatrix(filename,opts)</code></h4><p>通过配置opts参数，可以使得在导入数据的时候满足更多个性化需求。 <br>例如，假如我有一个电子表格文件 airlinesmall_subset.xlsx 包含 1996 年至2008 年间多个工作表中的数据。每个工作表都包含给定年份的数据。使用命令：<br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">opts.Sheet = <span class="hljs-string">&#x27;2007&#x27;</span>;    <span class="hljs-comment">%指定读取名称为‘2007’的工作表中的数据</span><br>opts.SelectedVariableNames = [<span class="hljs-number">1</span>:<span class="hljs-number">5</span>];     <span class="hljs-comment">%指定读取第1列到第5列的变量</span><br>opts.DataRange = <span class="hljs-string">&#x27;2:11&#x27;</span>;    <span class="hljs-comment">%指定读取第2行到第11行的数据</span><br>M = readmatrix(<span class="hljs-string">&#x27;airlinesmall_subset.xlsx&#x27;</span>,opts)<br><span class="hljs-comment">%相当于使用命令：M = readmatrix(&#x27;airlinesmall_subset.xlsx&#x27;,&#x27;Sheet&#x27;,&#x27;2007&#x27;,&#x27;Range&#x27;,&#x27;A2:E11&#x27;)</span><br></code></pre></td></tr></table></figure></p><h3 id="imread命令"><code>imread</code>命令</h3><p>从<strong>图形文件</strong>读取图像。</p><h4 id="a-imreadfilename"><code>A = imread(filename)</code></h4><p>从 filename 指定的文件读取图像，并从文件内容推断出其格式。如果filename 为多图像文件，则 imread 读取该文件中的第一个图像。 <br></p><h3 id="audioread命令暂定"><code>audioread</code>命令（暂定）</h3><p>将文件变量导入到工作区中，一般<strong>针对音频</strong>文件</p><h3 id="load命令"><code>load</code>命令</h3><p>将文件变量导入到工作区中，一般<strong>针对matlab特有的格式文件</strong>，即.mat文件。 <br> 注意：<strong>load 命令在初始化变量时可能会执行 MAT文件中包含的代码。请避免对不受信任的 MAT 文件调用 load</strong> <br>#### <code>load(filename)</code> 使用命令： <br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A = load(filename)       <span class="hljs-comment">%filename可以是.mat文件，也可以是ASCII文件（也叫文本文件即.txt文件）</span><br></code></pre></td></tr></table></figure> &gt;注：ASCII文件指含有用标准ASCII字符集编码的字符的数据和文本文件，只含有字母、数字和常见的符号。这种文件在磁盘中存放时每个字符对应一个8bits的字节，用于存放对应的ASCII码。区别于按二进制的编码方式来存放文件的二进制文件。- 如果 filename 是 MAT 文件，则load(filename) 会将 MAT文件中的变量加载到 MATLAB® 工作区，A是结构数组。 - 如果 filename 是ASCII 文件，load(filename) 会创建一个包含该文件数据的双精度数组。 <br>我们还可以通过下面两条命令来指定导入的文件类型，而不管文件拓展名是什么：<br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A = load(<span class="hljs-number">123.</span>mat, ‘-ascii’)   <span class="hljs-comment">%尽管文件后缀为mat格式，我们仍将其作为ascii文件导入</span><br></code></pre></td></tr></table></figure> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A = load(<span class="hljs-number">456.</span>txt, ‘-mat’)   <span class="hljs-comment">%尽管文件后缀为txt格式，我们仍将其作为mat文件导入</span><br></code></pre></td></tr></table></figure> &gt;注：<strong>load函数的命令形式</strong>，使用命令’loadfilename’，省去了括号和文件名字符串外面的引号，除此之外我也不知道为什么要创造这个命令形式。<br> ### <code>importdata</code>命令将数据导入到工作区中，可以导入各种类型的数据（如图片数据、数字、字符串等）、系统剪切板的数据等，函数的输入参数<code>delimiterIn</code>、<code>headerlinesIn</code>表示文件中的数据分隔符、以及我想从哪一行数据开始导入。<br> 附[mathworks官方importdata说明文档](https://ww2.mathworks.cn/help/matlab/ref/importdata.html#btldf1f-1)<br> <img src="/img/article/art4/pic1.png" alt="pic1" /> ####<code>importdata(filename,delimiterIn,headerlinesIn)</code>说人话：使用参数<code>delimiterIn</code>告诉matlab我们文件中的数据分隔符是什么。使用参数<code>headerlinesIn</code>告诉matlab我想从哪里开始导入数据。如：<br> 我们使用文本编辑器创建一个带有列标题的称为 myfile01.txt 的空格分隔ASCII 文件。 <br> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">Day1  Day2  Day3  Day4  Day5  Day6  Day7<br>95.01 76.21 61.54 40.57  5.79 20.28  1.53<br>23.11 45.65 79.19 93.55 35.29 19.87 74.68<br>60.68  1.85 92.18 91.69 81.32 60.38 44.51<br>48.60 82.14 73.82 41.03  0.99 27.22 93.18<br>89.13 44.47 17.63 89.36 13.89 19.88 46.60<br></code></pre></td></tr></table></figure> 输入以下命令： <br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">filename = <span class="hljs-string">&#x27;myfile01.txt&#x27;</span>;<br>delimiterIn = <span class="hljs-string">&#x27; &#x27;</span>;<br>headerlinesIn = <span class="hljs-number">1</span>;<br>A = importdata(filename,delimiterIn,headerlinesIn);<br><span class="hljs-comment">% 也就是A = importdata(‘myfile01.txt’, ‘ ’, 1);</span><br><span class="hljs-comment">% 注意，第二个单引号内存在一个空格</span><br></code></pre></td></tr></table></figure>上面的命令告诉我们，我们要导入一个叫做’myfile01.txt’的文本文件，它是以空格作为分隔符，并且我们导入从<strong>headerlinesIn+1</strong>=2行开始的<strong>数值数据</strong>。 <br>获得一个结构体输出：<br> <img src="/img/article/art4/pic2.png"alt="pic2" /> 导出了从第headerlinesIn+1即第二行开始的数值数据作为struct中的data，第headerlinesIn行作为colheaders，第一行到第headerlinesIn行的数据作为textdata。在缺省headerlinesIn参数的情况下importdata函数将会在文件中检测该值。 <br></p><h4id="adelimiteroutheaderlinesout-importdata___"><code>[A,delimiterOut,headerlinesOut] = importdata(___)</code></h4><p>在<code>delimiterOut</code>中额外返回检测到的输入 ASCII文件中的分隔符，以及在<code>headerlinesOut</code>中返回检测到的标题行数。<br></p><h4id="a-importdata-pastespecial"><code>A = importdata('-pastespecial')</code></h4><p>将系统剪切板上的数据导入给A变量，这个数据不能是图片，因为系统剪切板复制的图片并没有存储在当前目录中。### <code>uiimport</code>命令（暂定）</p>]]></content>
    
    
    <categories>
      
      <category>MATLAB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录今日破防</title>
    <link href="/2022/12/07/%E8%AE%B0%E5%BD%95%E4%BB%8A%E6%97%A5%E7%A0%B4%E9%98%B2/"/>
    <url>/2022/12/07/%E8%AE%B0%E5%BD%95%E4%BB%8A%E6%97%A5%E7%A0%B4%E9%98%B2/</url>
    
    <content type="html"><![CDATA[<p>在将添加的两篇测试文章“text”、“text2”删除后，重新生成并部署网站后，发现文章依旧在网站端页面显示，我就意识到了事情的不简单。之所以添加这两篇测试文章，是因为我发现我新提交的文章“构建笔记系统”无法在页面显示，于是我就重新提交了两篇测试文章，发现每新提交一篇文章，网页上就会显示上一次提交的文章，这让我很疑惑。<img src="/img/article/art3/p1.png" alt="pic1" /> <imgsrc="/img/article/art3/p2.png" alt="pic2" />我首先留意到了这样一段warning: <br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">warning: <span class="hljs-keyword">in</span> the working copy of <span class="hljs-string">&#x27;archives/2022/12/index.html&#x27;</span>, LF will be replaced by CRLF the next time Git touches it<br></code></pre></td></tr></table></figure><p>在google后了解到，这是由于在跨平台操作下CR(CarriageReturn：回车，与LF(LineFeed：换行，)可能会产生冲突。详参考博文<ahref="https://blog.csdn.net/u012757419/article/details/105614028">git提示“warning:LF will be replaced byCRLF”的解决办法_青崖林夕的博客-CSDN博客</a>，此处不再赘述。由于我日常主力还是在Windows上进行，还是默认设置Git在提交时自动把回车（CR）和换行（LF）转换成换行（LF）。使用命令:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#提交时转换为LF，检出时不转换</span><br>$ git config --global core.autocrlf <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>但我在提交新文章的时候仍然会产生这个warning，，， <br>然后我又输入了这样一条命令： <br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#提交时转换为LF，检出时不转换</span><br>$ git config core.autocrlf<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>再提交就不报warning了，很玄啊，<del>感觉在玩一种很新的东西</del><br>解决了这个warning，我闲着无事又刷新了网页，发现博客界面恢复正常了,给我整无语了。<br><img src="/img/article/art3/p3.png" alt="pic3" /></p><p>原来是从部署后到直接在页面显示出结果会有一定的延时，稍微等待一会就OK了，焯！建议大家以后提交博客后不要着急使用<code>hexo d</code>部署网站，先使用<code>hexo s</code>启用服务预览看一看页面是否正常后再部署，然后稍微<strong>耐心等待</strong>一会。<br>好了，折腾了将近两个小时，整了这么一出闹剧，下午还得复习复习半导体器件，估计明天就期中考试了。<br>啥都不会，救，，，</p>]]></content>
    
    
    
    <tags>
      
      <tag>网页部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建笔记系统</title>
    <link href="/2022/12/06/%E6%9E%84%E5%BB%BA%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/12/06/%E6%9E%84%E5%BB%BA%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>此文章是对B站UP主田浅浅发布的<ahref="https://www.bilibili.com/video/BV12N4y1c7KW/?spm_id_from=333.1007.top_right_bar_window_history.content.click">构建笔记系统</a>的一些整理，方便以后回顾。## 笔记的功能以不同的应用场景为例，涉及到笔记不同的功能：<strong>记录功能</strong>、<strong>理解功能</strong>、<strong>压缩功能</strong>。记住，学习的最终目的是让知识进入到脑子里不，是写给别人看的，可以不用太过追求美观。<br></p><h3 id="记录功能求全面">记录功能（求全面）</h3><p>在听讲座时，时间紧张，以扎住关键信息为主，体现以<strong>收集信息</strong>为目的的记录功能。<br></p><h3 id="理解功能读清晰">理解功能（读清晰）</h3><p>在阅读教材时，体现以<strong>整理加工信息</strong>为目的的理解功能，不要浪费时间抄书本上已有的信息。只有书上没有，需要补充的信息如新的发现、科技创新或将几本书籍的内容整合在一起时。可单独建立一个文档或一个笔记本，把不同来源的资料归一整合。<br>处理加工已经收集到的信息，变成自己能够理解的东西，分为两个步骤：<br></p><h4 id="信息管理">信息管理</h4><p>找出不同段落之间的内在联系，是宏观上的信息管理；找出不同句子和词之间的联系，是微观上的信息管理。</p><h4 id="知识管理">知识管理</h4><p>它表征了我们学习时对知识的掌握程度。将接触到的知识<strong>进行分类</strong>如：重点，难点，是否掌握，是否牢固，是否需要针对性做题复习等等。<br>可使用不同颜色标注，示例：<br><font color = #66FF66 size=5 face="宋体">【难点+没懂】!!!</font>意思是这里很难并且我还没弄懂。 <br><font color = #ff0000 size=5 face="宋体">【难点+懂了】难句子</font>意思是这个地方虽然很难，但我已经掌握了，只需要稍后去复习。 <br><font color = #66ccff size=5 face="宋体">【重点、概括性】句子</font>很重要，需要加强理解。 <br><font color = #ffd700 size=5 face="宋体">【重要概念】名词</font>标注一些重要的名词。 <br></p><h3 id="压缩功能厚书读薄">压缩功能（厚书读薄）</h3><p><strong>建立在理解和记忆的基础上</strong>，把信息概括成一个一个的组块，关键在于把句子压缩到<strong>尽可能简洁</strong><br>由于大脑容量有限，无法准确记忆每一个句子，我们可以使用关键词概括一整段的资料。极度压缩信息，比如思维导图，形成一个完整的框架。复习时大脑进行知识闪回，知识流扩散，重组。<br>可以记在笔记本上，亦可以直接写在书本上（如政治课）。这一步可以用一些速记符号，记忆口诀、联想法和记忆迷宫等方式</p><h3 id="检测功能知识入脑">检测功能（知识入脑）</h3><p>学习的目的是记忆、掌握知识，笔记就是用来复习检验，确保真正记忆理解了信息。<br>利用第三步压缩的框架，回忆整个知识点。当你把整个框架都从单个的概括压缩性的词还原成书本上的文段和句子后，进行<strong>查漏补缺</strong>，并做好对应的标记。</p><p><strong>一句话概括：理解→化繁为简→记忆→化简为繁→查漏补缺。把书从厚读薄，再从薄读厚</strong></p>]]></content>
    
    
    <categories>
      
      <category>软实力</category>
      
    </categories>
    
    
    <tags>
      
      <tag>涉猎集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>序章</title>
    <link href="/2022/12/05/hello-world/"/>
    <url>/2022/12/05/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="序">序</h2><p>GitHub IO, <strong>我来啦!</strong>折腾了一天，终于搭建好了属于自己的博客！<br><del>以后就可以在这个小窝安心地生产垃圾啦</del><br>咳咳，我要记录想法、学习心得以供将来参考<del>顺便有事没事倾诉一下苦水、发发牢骚</del><br></p><h2 id="小小记录一下几个命令">小小记录一下几个命令</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server / 常简写为hexo s<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate / 常简写为hexo g<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy / 常简写为hexo g<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>遐想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

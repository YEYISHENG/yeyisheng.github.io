<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>文创卡片使用指南</title>
    <link href="/2024/12/18/%E6%96%87%E5%88%9B%E5%8D%A1%E7%89%87%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2024/12/18/%E6%96%87%E5%88%9B%E5%8D%A1%E7%89%87%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Gjne3">如何DIY？</h1><p>最近在B站上看到很多这种类似的DIY校园卡的项目，觉得很有趣，结果找了半天没找到自己学校的卡片设计，于是我就想着自己上阵弄一个出来。方法与设计都参考了B站的同类视频，如果哪里有不懂的地方都可以去看一看。</p><p>我在这里就说一说我遇到的一些问题：</p><p>1、获取校园地图元素</p><p>首先是关于校园地图元素的设计：那首先你得先搞到自个儿学校的地图，这个应该不用我多说，在官网应该都能找到。就像这样，不过在这里还是要吐槽一下国科大雁栖湖校区，我还是头一次见到长条状的校区，东西两个校区都是狭长分布的，像条泥鳅一样。</p><p>2、将其转化为电路</p><p>你可以在PS等软件中把地图按照你喜欢的样式重新绘制出来，然后把它导入为丝印层；也可以像我一样偷个懒，直接利用EDA中的元器件进行绘制，地图里面长得比较规则的图形可以使用EDA中现成的元件例如电阻电容电感、运放、晶振、滑动变阻器等等，遇到不规则的图形比如操场、游泳池或者其他你想DIY的图形（比如你的校园卡芯片的封装），你可以将他们封装为自定义器件。</p><p>具体来说，首先需要新建元件库，然后在元件库中创建元件及其对应的封装，这里我解释一下：元件库里面可以创建很多元件，每一个元件都是放置在电路原理图（Schematic）上的，而与之对应的封装则是实际打板后得到的实物，有点类似于光刻工艺中的掩膜版，你画的是什么形状最后就会得到什么形状。</p><p><img src="/img/article/art-pcb/1.png" /></p><p>具体步骤如下：首先创建元件并绘制形状，什么形状都可以，只要你看的过去就行。</p><p><img src="/img/article/art-pcb/2.png" alt="创建元件" /><imgsrc="/img/article/art-pcb/3.png" alt="绘制元件，什么形状都可以" /></p><p>接着创建封装并绘制形状，这里的形状与尺寸参数需要仔细斟酌，因为它与你最终打板得到的实物息息相关。</p><p><img src="/img/article/art-pcb/4.png" alt="创建封装" /><imgsrc="/img/article/art-pcb/5.png" alt="绘制封装，需要仔细设计" /></p><p>然后将元件与其对应的封装进行绑定。</p><figure><img src="/img/article/art-pcb/6.png" alt="将元件与封装绑定" /><figcaption aria-hidden="true">将元件与封装绑定</figcaption></figure><figure><img src="/img/article/art-pcb/7.png" alt="绑定成功" /><figcaption aria-hidden="true">绑定成功</figcaption></figure><p>最后你就可以在PCB图中看到你设计的元件了，可以随意摆放到你喜欢的位置。</p><p><img src="/img/article/art-pcb/8.png" /></p><p>3、关于线圈长度</p><p>严格来说，线圈长度是有要求的，因为涉及到电磁感、阻抗匹配以及对应的功率转换问题，否则可能出现有些小功率NFC读卡器刷你的卡没有反应的情况。线圈长度的计算有对应的公式，但秉着将懒惰贯彻到底的精神，我就设计了尽可能长的线圈长度。</p><p><img src="/img/article/art-pcb/9.png" /></p><h1 id="YLCDE">如何使用？</h1><p>在不进行任何操作的情况下，起码LED灯是能够正常发光的。不过如果你有更高的需求，目前也有以下三种操作方案：</p><p>1、写入一些快捷功能，比如播放音乐、视频、打开网页、软件等等，这需要下载NFC标签助手，浏览器都可以下载。操作教程<ahref=""title="https://www.bilibili.com/video/BV17uWLexEGS/?spm_id_from=333.337.search-card.all.click&amp;vd_source=539b37ff657994ee05cbd99be4724bca">在这里</a></p><p><img src="/img/article/art-pcb/10.png" /></p><p>2、复制校园卡信息，获得“简易校园卡”，为什么我说它是简易校园卡呢？因为很多校园卡功能它不能实现，比如最常见的消费功能，这种数据是经过加密的，如果我能获取，那我现在不是囚犯就是副研究员（doge。复制之后的校园卡只能刷开宿舍一楼的门禁，同时还能刷“碧小荷”饮水机，嗯就是那个需要往里面充钱的那个。其他的一概刷不了！！！包括大门门禁、教室门禁、图书馆门禁、套件门禁以及使用校园卡金额的饮水机，大家也不要去刷这些，否则“简易校园卡”里面的数据会被篡改而导致报废。</p><p>同样的，复制校园卡信息也需要相应的软件——腾远RFID，这个我是在华为应用商店里面下载的，浏览器下载的用不了。</p><p><img src="/img/article/art-pcb/11.png" /></p><p>操作流程如下：</p><ul><li>将你的校园卡紧贴在手机后面，读取扇区数据，记下扇区0块0的数据（也就是第一行数据）</li></ul><p><img src="/img/article/art-pcb/12.png" /></p><ul><li>将简易校园卡（PCB板）紧贴在手机后面，读取扇区数据，记下扇区0块0的数据（也就是第一行数据）</li></ul><p><img src="/img/article/art-pcb/13.png" /></p><ul><li>切换到写入模式，将校园卡前10位数字（红线部分）与建议校园卡后22位数字拼接在一块，选择卡类型为TUID，选择扇区编号为00，将简易校园卡紧贴在手机后面，即可自动完成写入。</li></ul><p><img src="/img/article/art-pcb/14.png" /></p><p>3、把你的校园卡里面的NFC芯片取出（网上自行购买二氯甲烷溶剂进行校园卡溶解，注意在通风处操作，二氯甲烷有毒，其受热分解后产生的光气毒性较强，请谨慎使用），然后将其焊接到PCB上，获得满血校园卡，可以解锁校园卡的所有功能。代价是你需要掌握相应的焊接知识、拥有焊接工具、卡片拆解工具以及小吸几口焊接时产生的微毒气体，或者一个愿意帮你焊接的工具人（bushi</p><h1 id="EFeT0">Furthermore</h1><p>接下来是天马行空时刻！</p><p>后续会有哪些改进呢？或许可以加上一个每一个电子人都喜闻乐道的OLED屏幕，显示出更多有意思的信息，那这样可能需要独立的供电系统，还需要编写相应的驱动；或者设计出与NFC进行交互的APP，实现任意自定义的功能，比如之前和朋友讨论的打印校友信息的功能，还蛮有意思的；或者简单一点，在卡套上面做些文章，每次刷卡的时候，卡套上绘制的电路线条流动式地点亮，有种流光溢彩的呼吸效果，想想是不是也很酷？</p><p>无论最后是否能实现，想法总是要有的，万一实现了呢？</p><hr /><p><ahref="https://www.bilibili.com/video/BV1Ru4y1D7PL/?spm_id_from=333.788.videopod.sections&amp;vd_source=539b37ff657994ee05cbd99be4724bca">【教程】手把手教你玩转IC卡-第1章-第3节-复制卡和防火墙_哔哩哔哩_bilibili</a></p><p><ahref="https://www.bilibili.com/video/BV1Er14YfEaR?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=539b37ff657994ee05cbd99be4724bca">手机nfc制作复制门禁卡教程_哔哩哔哩_bilibili</a></p><p><ahref="https://www.bilibili.com/video/BV1xh4y1t7Qd/?spm_id_from=333.337.search-card.all.click&amp;vd_source=539b37ff657994ee05cbd99be4724bca">教你做一款酷炫的PCB发光校园卡_哔哩哔哩_bilibili</a></p><p><ahref="https://www.bilibili.com/video/BV1rvUeYoEPK/?spm_id_from=333.337.search-card.all.click&amp;vd_source=539b37ff657994ee05cbd99be4724bca">2分钟教你制作属于自己的校园卡PCB！！_哔哩哔哩_bilibili</a></p><p><ahref="https://www.bilibili.com/video/BV1fM411Z7cW?spm_id_from=333.788.videopod.episodes&amp;vd_source=539b37ff657994ee05cbd99be4724bca&amp;p=6">01-3-元器件的符号和封装_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>涉猎集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>just for fun</tag>
      
      <tag>PCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次型解决超前进位加法器——32位CLA的实现</title>
    <link href="/2024/11/21/%E4%B8%80%E6%AC%A1%E5%9E%8B%E8%A7%A3%E5%86%B3%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8%E2%80%94%E2%80%9432%E4%BD%8DCLA%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/11/21/%E4%B8%80%E6%AC%A1%E5%9E%8B%E8%A7%A3%E5%86%B3%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8%E2%80%94%E2%80%9432%E4%BD%8DCLA%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>网上现有的资料，虽然很多，但是要么杂乱无章，要么不成体系。本来我觉得是很简单的一个问题，看了一圈下来，半小时过去竟然还是云里雾里。一怒之下，翻开我本科计组课件，花了几分钟浏览了一下，顿感拨云见日，浑身舒爽。<br>超前进位加法器的核心思想是并行计算进位位，我们想要超前计算的就是进位信号C，这个思想将会贯彻加法器的设计始终，从最初的4bitCLA到16bitCLA组间进位都体现了这个思想。<br>我们先从最简单的一位全加器开始说起，观察普通一位全加器的逻辑表达式：<br><span class="math display">\[\left\{\begin{array}{l}s=a\oplus b\oplus c ,\\c_{out}=ab+c_{in}(a\oplus b)\end{array}\right.\]</span></p><p>其中a与b是两个加数、<spanclass="math inline">\(c_{in}\)</span>是低位进位信号、s是和数、<spanclass="math inline">\(c_{out}\)</span>是高位进位，这里的五个信号都是1bit的。由于进位是由低位向高位逐级传递，进位的逻辑形似链条，所以将进位传递逻辑叫做进位链CarryLink。我们可以看出，如果将位数从一位扩展到多位，高位进位信号总是依赖低位进位信号的，这就会造成非常可观的延迟，运算速度与进位传递速度有关。于是又引入了数字IC设计中亘古不变的话题，面积与速度的tradeoff，只不过这次我们是用面积换速度，即使用更复杂的电路设计换取更快的运行速度。<br>人们开始想办法优化电路结构，提取其共有部分： <spanclass="math display">\[\left\{\begin{array}{l}P=a\oplus b ,\\G=ab\end{array}\right.\]</span> 这里的a与b是输入的待求和数据，即可以是1bit的也可以是Nbits的数据。<br>于是，对于N位超前进位加法器，进位与求和的逻辑表达式可以重新写成如下形式：<br><span class="math display">\[\left\{\begin{array}{l}s_i=Pi \oplus c_{i-1}, &amp; &amp;i=1,...,N \\c_i=G_i\oplus c_{i-1}P_i, &amp; &amp; i=1,...,N \\c_0=c_{in} &amp; &amp; \\c_{out}=c_N &amp; &amp;\end{array}\right.\]</span> 其中： <span class="math display">\[\left\{\begin{array}{l}P_i=a_i\oplus b_i, &amp; &amp;i=0,1,...,N-1 \\G_i=a_ib_i, &amp; &amp;i=0,1,...,N-1\end{array}\right.\]</span>写到这里，如果照着公式接着硬讲下去，那就又走上了网上其他人的老路，但我不想听你讲公式，能不能来点实际的、形象一点的、能让知识在不觉间水灵灵地流入我的脑子。<br></p><p>首先，从命名开始说起，难道大家就没有好奇P和G是怎么冒出来的？为啥不用L、M、N？这26个字母排着队地等着上呢，怎么就冒出个P和G？原来，G被称为进位生成（generate）函数，P被称为进位传递（propagate）函数，计组课件里有一张图我觉得十分形象（我为郑老师打call）：低位进位<spanclass="math inline">\(c_0\)</span>与进位生成信号g都能产生进位信号，它们就像管道中的补水口，控制水的来源；而进位传递信号p则是一级级传递进位信号，它们则像是管道中的水阀，控制水的流通。<br><img src="/img/article/art-cla/1.png"alt="图 1 Generate&amp;Propagate" /></p><p>于是，进位信号就像水流一样在管道里被一级级的水阀放行，而且这个过程是并行的，一旦配置好进位链，你能同时得到c1、c2、c3等所有的进位信号，实现了超前进位，也就是提前计算好所有的进位信号。我们所需要做的仅仅就是配置好这个进位链，怎么配置？人家公式不都告诉你了：<br><span class="math display">\[\left\{\begin{array}{l}P_i=a_i\oplus b_i, &amp; &amp;i=0,1,...,N-1 \\G_i=a_ib_i, &amp; &amp;i=0,1,...,N-1\end{array}\right.\]</span> <span class="math display">\[\left\{\begin{array}{l}s_i=Pi \oplus c_{i-1}, &amp; &amp;i=1,...,N \\c_i=G_i\oplus c_{i-1}P_i, &amp; &amp; i=1,...,N \\c_0=c_{in} &amp; &amp; \\c_{out}=c_N &amp; &amp;\end{array}\right.\]</span></p><p>如果仅仅是实现一个4bit的超前进位加法器，其示意图如下所示：<br> <imgsrc="/img/article/art-cla/2.png" alt="图 2 4bit CLA" /></p><p>PG Generator用来产生P和G，其内部执行了下述操作： <spanclass="math display">\[\left\{\begin{array}{l}P_i=a_i\oplus b_i, &amp; &amp;i=0,1,...,N-1 \\G_i=a_ib_i, &amp; &amp;i=0,1,...,N-1\end{array}\right.\]</span></p><p>4bitCLA利用上面产生的P与G信号，生成进位信号c，其内部执行了下述操作：<span class="math display">\[\left\{\begin{array}{l}c_1=G_1+c_0P_1 \\c_2=G_2+c_1P_2=G_2+(G_1+c_0P_1)P_2=G_2+G_1P_2+c_0P_2P_1 \\c_3=G_3+c_2P_3=G_3+(G_2+G_1P_2+c_0P_1P_1)P_3=G_3+G_2P_3+G_1P_3P_2+c_0P_3P_2P_1\\c_4=G_4+c_3P_4=G_4+(G_3+G_2P_3+G_1P_3P_2+c_0P_3P_2P_1)P_4=G_4+G_3P_4+G_2P_4P_3+G_1P_4P_3P_2+c_0P_4P_3P_2P_1\end{array}\right.\]</span></p><p>最后的和数由进位传递信号P与进位信号c异或得到，注意第四位进位信号<spanclass="math inline">\(c_4\)</span>是高位进位，用来传递给下一级电路的，其计算逻辑如下：<span class="math display">\[\left\{\begin{array}{l}s_0=P_0\oplus c_0 \\s_1=P_1\oplus c_1 \\s_2=P_2\oplus c_2 \\s_3=P_3\oplus c_3\end{array}\right.\]</span></p><p>如果涉及到大位数的超前进位加法器——例如我想实现一个16bit超前进位器，还是使用上面的方法构建的话，会在进位链中引入超高扇入的逻辑门，使得整体电路规模以指数级增长。<br>为了控制超前进位电路的进位链复杂度，我们可以将一条较大的完整的超前进位链划分为多块较小的超前进位链块，也就是将16bitCLA分成4组4bitCLA，如下图所示：<br><img src="/img/article/art-cla/3.png"alt="图 3 将16bitCLA分成4组4bitCLA" /></p><p>这就是最简单的组内超前进位、组间串行进位，也就是说每一个4bitCLA内部是超前进位的，而4组4bitLCA之间是串行进位的，<spanclass="math inline">\(c_4\)</span>、<spanclass="math inline">\(c_8\)</span>、<spanclass="math inline">\(c_{12}\)</span>与<spanclass="math inline">\(c_{16}\)</span>的产生不是并行的，<spanclass="math inline">\(c_4\)</span>的产生依赖于第一组4bitLCA的<spanclass="math inline">\(c_0\)</span>、<spanclass="math inline">\(c_8\)</span>的产生依赖于第二组4bitLCA的<spanclass="math inline">\(c_4\)</span>，以此类推。 <br>于是就会产生一个疑问：能否实现组间并行进位？ 我们仔细分析一下<spanclass="math inline">\(c_4\)</span>信号： <span class="math display">\[c_4=G_4+c_3P_4=G_4+(G_3+G_2P_3+G_1P_3P_2+c_0P_3P_2P_1)P_4=G_4+G_3P_4+G_2P_4P_3+G_1P_4P_3P_2+c_0P_4P_3P_2P_1\]</span> 发现它也能拆开为超前进位的形式： <span class="math display">\[\left\{\begin{array}{l}G_4^*=G_4+G_3P_4+G_2P_4P_3+G_1P_4P_3P_2 \\P_4^*=P_4P_3P_2P_1\end{array}\right.\]</span></p><p>我们把G4<em>与P4</em>称为成组进位信号，有了它俩，c4可以写成： <spanclass="math display">\[c_4=G_4^*+P_4^*c_0\]</span></p><p>有意思的是，产生C4的逻辑与之前产生组内进位信号ci的逻辑表达式是一模一样的：<span class="math display">\[c_i=G_i\oplus c_{i-1}P_i,i=1,...,N\]</span></p><p>于是我们得出下面的结论：<strong>组内、组间并行进位链的逻辑形态完全相同</strong><br>这个结论非常重要，这意味着我们在处理组间并行进位时可以完全复用原有的4bitCLA电路，只需要将原有4bitCLA模块中接入<spanclass="math inline">\(G_4^*\)</span>、<spanclass="math inline">\(G_8^*\)</span>、<spanclass="math inline">\(G_{12}^*\)</span>、<spanclass="math inline">\(G_{16}^*\)</span>、<spanclass="math inline">\(P_4^*\)</span>、<spanclass="math inline">\(P_8^*\)</span>、<spanclass="math inline">\(P_{12}^*\)</span>、<spanclass="math inline">\(P_{16}^*\)</span>即可产生之前需要串行等待的<spanclass="math inline">\(c_4\)</span>、<spanclass="math inline">\(c_8\)</span>、<spanclass="math inline">\(c_{12}\)</span>与<spanclass="math inline">\(c_{16}\)</span>，降低了延时的同时也没有增加额外的设计，因为我们还是复用了原有的CLA电路，只是增加了硬件资源开销，没有增加设计开销。<br> 于是，改进之后的电路如下图所示：<br> <imgsrc="/img/article/art-cla/4.png" alt="图 4 改进后的16bitCLA" /></p><p>简洁起见，上面4个CLA中的成组进位信号我没加*，我们心里知道那是成组进位信号就行了。<br>扩展到32bitCLA的设计，也是这个道理，我们先来看组间串行进位的32bitCLA：<br><img src="/img/article/art-cla/5.png"alt="图 5 组间串行进位的32bitCLA" /></p><p>图中标蓝色部分表示生成的4bit进位信号有3bit来自CLA，1bit来自地位进位，是二者的组合；图中标红色部分表示着组间串行进位。<br>超前进位的思想同样可以应用到图中两个标红色部分的进位链信号的产生与传递，所以我们可以将闲置的<spanclass="math inline">\(P_4^*G_4^*\)</span>与<spanclass="math inline">\(P_8^*G_8^*\)</span>利用起来，再额外使用一个4bitCLA来产生这两个进位信号，如下所示：<img src="/img/article/art-cla/6.png"alt="图 6 组间并行进位的32bitCLA" /></p><p>最后贴出verilog代码供大家参考： <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add_cla_4_4(<br>    <span class="hljs-keyword">input</span>   <span class="hljs-keyword">wire</span>    [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]   p,<br>    <span class="hljs-keyword">input</span>   <span class="hljs-keyword">wire</span>    [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]   g,<br>    <span class="hljs-keyword">input</span>   <span class="hljs-keyword">wire</span>            cin,<br><br>    <span class="hljs-keyword">output</span>  <span class="hljs-keyword">wire</span>            P,      <span class="hljs-comment">//组间进位信号（成组进位信号）</span><br>    <span class="hljs-keyword">output</span>  <span class="hljs-keyword">wire</span>            G,      <span class="hljs-comment">//组间进位信号（成组进位信号）</span><br>    <span class="hljs-keyword">output</span>  <span class="hljs-keyword">wire</span>    [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>]   cout    <span class="hljs-comment">//第四位cout信号被拆分为P与G</span><br>);<br><br>    <span class="hljs-keyword">assign</span> P = p[<span class="hljs-number">3</span>]&amp;p[<span class="hljs-number">2</span>]&amp;p[<span class="hljs-number">1</span>]&amp;p[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">assign</span> G = g[<span class="hljs-number">3</span>]|(p[<span class="hljs-number">3</span>]&amp;g[<span class="hljs-number">2</span>])|(p[<span class="hljs-number">3</span>]&amp;p[<span class="hljs-number">2</span>]&amp;g[<span class="hljs-number">1</span>])|(p[<span class="hljs-number">3</span>]&amp;p[<span class="hljs-number">2</span>]&amp;p[<span class="hljs-number">1</span>]&amp;g[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">assign</span> cout[<span class="hljs-number">0</span>] = g[<span class="hljs-number">0</span>]|(p[<span class="hljs-number">0</span>]&amp;cin);<br>    <span class="hljs-keyword">assign</span> cout[<span class="hljs-number">1</span>] = g[<span class="hljs-number">1</span>]|(p[<span class="hljs-number">1</span>]&amp;g[<span class="hljs-number">0</span>])|(p[<span class="hljs-number">1</span>]&amp;p[<span class="hljs-number">0</span>]&amp;cin);<br>    <span class="hljs-keyword">assign</span> cout[<span class="hljs-number">2</span>] = g[<span class="hljs-number">2</span>]|(p[<span class="hljs-number">2</span>]&amp;g[<span class="hljs-number">1</span>])|(p[<span class="hljs-number">2</span>]&amp;p[<span class="hljs-number">1</span>]&amp;g[<span class="hljs-number">0</span>])|(p[<span class="hljs-number">2</span>]&amp;p[<span class="hljs-number">1</span>]&amp;p[<span class="hljs-number">0</span>]&amp;cin);<br>    <span class="hljs-comment">// assign cout[3] = g[3]|(p[3]&amp;g[2])|(p[3]&amp;p[2]&amp;g[1])|(p[3]&amp;p[2]&amp;p[1]&amp;g[0])|(p[3]&amp;p[2]&amp;p[1]&amp;p[0]&amp;cin);</span><br>    <span class="hljs-comment">// cout[3] = P|G&amp;cin;</span><br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> add_cla_32_32<br>(<br>    <span class="hljs-keyword">input</span>   <span class="hljs-keyword">wire</span>    [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]   A,<br>    <span class="hljs-keyword">input</span>   <span class="hljs-keyword">wire</span>    [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]   B,<br><br>    <span class="hljs-keyword">output</span>  <span class="hljs-keyword">wire</span>    [<span class="hljs-number">32</span>:<span class="hljs-number">0</span>]   Sum<br>);<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] p;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] g;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] c;<br><span class="hljs-keyword">wire</span> c_x;<br><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">9</span>:<span class="hljs-number">0</span>]  P;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">9</span>:<span class="hljs-number">0</span>]  G;<br><br><span class="hljs-keyword">assign</span> c[<span class="hljs-number">0</span>] = <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">assign</span> p = A^B;<br><span class="hljs-keyword">assign</span> g = A&amp;B;<br><br>add_tc_4_4 add_tc_4_4_inst0_0(<span class="hljs-variable">.p</span>(p[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]),<span class="hljs-variable">.g</span>(g[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]),<span class="hljs-variable">.cin</span>(c[<span class="hljs-number">0</span>]),<span class="hljs-variable">.P</span>(P[<span class="hljs-number">0</span>]),<span class="hljs-variable">.G</span>(G[<span class="hljs-number">0</span>]),<span class="hljs-variable">.cout</span>(c[<span class="hljs-number">3</span>:<span class="hljs-number">1</span>]));<br>add_tc_4_4 add_tc_4_4_inst0_1(<span class="hljs-variable">.p</span>(p[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>]),<span class="hljs-variable">.g</span>(g[<span class="hljs-number">7</span>:<span class="hljs-number">4</span>]),<span class="hljs-variable">.cin</span>(c[<span class="hljs-number">4</span>]),<span class="hljs-variable">.P</span>(P[<span class="hljs-number">1</span>]),<span class="hljs-variable">.G</span>(G[<span class="hljs-number">1</span>]),<span class="hljs-variable">.cout</span>(c[<span class="hljs-number">7</span>:<span class="hljs-number">5</span>]));<br>add_tc_4_4 add_tc_4_4_inst0_2(<span class="hljs-variable">.p</span>(p[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>]),<span class="hljs-variable">.g</span>(g[<span class="hljs-number">11</span>:<span class="hljs-number">8</span>]),<span class="hljs-variable">.cin</span>(c[<span class="hljs-number">8</span>]),<span class="hljs-variable">.P</span>(P[<span class="hljs-number">2</span>]),<span class="hljs-variable">.G</span>(G[<span class="hljs-number">2</span>]),<span class="hljs-variable">.cout</span>(c[<span class="hljs-number">11</span>:<span class="hljs-number">9</span>]));<br>add_tc_4_4 add_tc_4_4_inst0_3(<span class="hljs-variable">.p</span>(p[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>]),<span class="hljs-variable">.g</span>(g[<span class="hljs-number">15</span>:<span class="hljs-number">12</span>]),<span class="hljs-variable">.cin</span>(c[<span class="hljs-number">12</span>]),<span class="hljs-variable">.P</span>(P[<span class="hljs-number">3</span>]),<span class="hljs-variable">.G</span>(G[<span class="hljs-number">3</span>]),<span class="hljs-variable">.cout</span>(c[<span class="hljs-number">15</span>:<span class="hljs-number">13</span>]));<br>add_tc_4_4 add_tc_4_4_inst0_4(<span class="hljs-variable">.p</span>(P[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]),<span class="hljs-variable">.g</span>(G[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]),<span class="hljs-variable">.cin</span>(c[<span class="hljs-number">0</span>]),<span class="hljs-variable">.P</span>(P[<span class="hljs-number">4</span>]),<span class="hljs-variable">.G</span>(G[<span class="hljs-number">4</span>]),<span class="hljs-variable">.cout</span>(&#123;c[<span class="hljs-number">12</span>],c[<span class="hljs-number">8</span>],c[<span class="hljs-number">4</span>]&#125;));<br><br>add_tc_4_4 add_tc_4_4_inst1_0(<span class="hljs-variable">.p</span>(p[<span class="hljs-number">19</span>:<span class="hljs-number">16</span>]),<span class="hljs-variable">.g</span>(g[<span class="hljs-number">19</span>:<span class="hljs-number">16</span>]),<span class="hljs-variable">.cin</span>(c[<span class="hljs-number">16</span>]),<span class="hljs-variable">.P</span>(P[<span class="hljs-number">5</span>]),<span class="hljs-variable">.G</span>(G[<span class="hljs-number">5</span>]),<span class="hljs-variable">.cout</span>(c[<span class="hljs-number">19</span>:<span class="hljs-number">17</span>]));<br>add_tc_4_4 add_tc_4_4_inst1_1(<span class="hljs-variable">.p</span>(p[<span class="hljs-number">23</span>:<span class="hljs-number">20</span>]),<span class="hljs-variable">.g</span>(g[<span class="hljs-number">23</span>:<span class="hljs-number">20</span>]),<span class="hljs-variable">.cin</span>(c[<span class="hljs-number">20</span>]),<span class="hljs-variable">.P</span>(P[<span class="hljs-number">6</span>]),<span class="hljs-variable">.G</span>(G[<span class="hljs-number">6</span>]),<span class="hljs-variable">.cout</span>(c[<span class="hljs-number">23</span>:<span class="hljs-number">21</span>]));<br>add_tc_4_4 add_tc_4_4_inst1_2(<span class="hljs-variable">.p</span>(p[<span class="hljs-number">27</span>:<span class="hljs-number">24</span>]),<span class="hljs-variable">.g</span>(g[<span class="hljs-number">27</span>:<span class="hljs-number">24</span>]),<span class="hljs-variable">.cin</span>(c[<span class="hljs-number">24</span>]),<span class="hljs-variable">.P</span>(P[<span class="hljs-number">7</span>]),<span class="hljs-variable">.G</span>(G[<span class="hljs-number">7</span>]),<span class="hljs-variable">.cout</span>(c[<span class="hljs-number">27</span>:<span class="hljs-number">25</span>]));<br>add_tc_4_4 add_tc_4_4_inst1_3(<span class="hljs-variable">.p</span>(p[<span class="hljs-number">31</span>:<span class="hljs-number">28</span>]),<span class="hljs-variable">.g</span>(g[<span class="hljs-number">31</span>:<span class="hljs-number">28</span>]),<span class="hljs-variable">.cin</span>(c[<span class="hljs-number">28</span>]),<span class="hljs-variable">.P</span>(P[<span class="hljs-number">8</span>]),<span class="hljs-variable">.G</span>(G[<span class="hljs-number">8</span>]),<span class="hljs-variable">.cout</span>(c[<span class="hljs-number">31</span>:<span class="hljs-number">29</span>]));<br>add_tc_4_4 add_tc_4_4_inst1_4(<span class="hljs-variable">.p</span>(P[<span class="hljs-number">8</span>:<span class="hljs-number">5</span>]),<span class="hljs-variable">.g</span>(G[<span class="hljs-number">8</span>:<span class="hljs-number">5</span>]),<span class="hljs-variable">.cin</span>(c[<span class="hljs-number">16</span>]),<span class="hljs-variable">.P</span>(P[<span class="hljs-number">9</span>]),<span class="hljs-variable">.G</span>(G[<span class="hljs-number">9</span>]),<span class="hljs-variable">.cout</span>(&#123;c[<span class="hljs-number">28</span>],c[<span class="hljs-number">24</span>],c[<span class="hljs-number">20</span>]&#125;));<br><br>add_tc_4_4 add_tc_4_4_inst2(<span class="hljs-variable">.p</span>(&#123;<span class="hljs-number">2&#x27;b00</span>,P[<span class="hljs-number">9</span>],P[<span class="hljs-number">4</span>]&#125;),<span class="hljs-variable">.g</span>(&#123;<span class="hljs-number">2&#x27;b00</span>,G[<span class="hljs-number">9</span>],G[<span class="hljs-number">4</span>]&#125;),<span class="hljs-variable">.cin</span>(c[<span class="hljs-number">0</span>]),<span class="hljs-variable">.P</span>(),<span class="hljs-variable">.G</span>(),<span class="hljs-variable">.cout</span>(&#123;c_x,Sum[<span class="hljs-number">32</span>],c[<span class="hljs-number">16</span>]&#125;));<br><br><span class="hljs-keyword">assign</span> Sum[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] = p^c;<br>    <br><span class="hljs-keyword">endmodule</span><br><br></code></pre></td></tr></table></figure><p>Modelsim仿真结果如下图，我使用的是xilinx的zynq7020也就是xc7z020clg400-1这块片子：<img src="/img/article/art-cla/7.png" alt="图 7 Modelsim仿真" /></p><figure><img src="/img/article/art-cla/8.png" alt="图 8 逻辑资源占用" /><figcaption aria-hidden="true">图 8 逻辑资源占用</figcaption></figure><figure><img src="/img/article/art-cla/9.png" alt="图 9 功耗仿真" /><figcaption aria-hidden="true">图 9 功耗仿真</figcaption></figure><p>可以看出逻辑是正确的，但由于没有绑定IO端角，所以导致On-ChipPower有些大。<br></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字IC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>加法器优化</tag>
      
      <tag>超前进位</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脚本执行指令辨析（source , . , sh , bash , ./）</title>
    <link href="/2024/06/21/%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E8%BE%A8%E6%9E%90/"/>
    <url>/2024/06/21/%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E8%BE%A8%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>大体上来说，脚本执行指令可以分为两类：<strong>子程序内执行</strong>与<strong>父程序内执行</strong>。如果再分得细些的话，那么子程序内执行又可以分为<strong>直接指令下达</strong>与<strong>以bash程序执行</strong>这两种。<br></p><h2 id="父程序与子程序">父程序与子程序</h2><p>当你登陆 Linux 并取得一个 bash 之后，你的 bash就是一个独立的程序，被称为 PID 的就是。 接下来你在这个 bash底下所下达的任何命令都是由这个 bash所衍生出来的，那些被下达的命令就被称为子程序了<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[认识和学习bash](http://cn.linux.vbird.org/linux_basic/0320bash.php#export)">[1]</span></a></sup>。父程序与子程序之间的关系可以用以下的图示来表明：<br></p><figure><img src="/img/article/art-scripts-exec/子程序.png"alt="图1 父程序与子程序" /><figcaption aria-hidden="true">图1 父程序与子程序</figcaption></figure><p>如果在当前bash中再开启一个新的bash时，那么当前的bash则成了父程序，而新开的bash就是子程序。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash        <span class="hljs-comment">#进入子程序</span><br><br><span class="hljs-built_in">exit</span>        <span class="hljs-comment">#退出子程序</span><br></code></pre></td></tr></table></figure><p>二者的特点是：<br> -父程序的自定义变量不会被子程序继承，仅环境变量可以被子程序继承 -子程序结束后，子程序内的各项变量或动作将会结束而不会传回父程序</p><p>使用<code>export</code>指令将自定义变量转化为环境变量后，这个变量就能够被子程序继承了。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> 变量名称<br></code></pre></td></tr></table></figure></p><h2 id="子程序内执行">子程序内执行</h2><p>顾名思义，以此类指令执行的脚本将会在子程序内执行，不会继承父程序的变量。子程序内执行又分为<strong>直接指令下达</strong>与<strong>以bash程序执行</strong>这两种<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Bash Shell的操作环境](http://cn.linux.vbird.org/linux_basic/0320bash_4.php)">[2]</span></a></sup>。<br></p><h3id="直接指令下达绝对路径相对路径与path">直接指令下达（绝对路径、相对路径与$PATH）</h3><p>如果以直接指令下达的方式运行脚本，需要脚本具有可执行权限，因此，在执行脚本前还需要额外加一句下面的指令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> a+x scripts.sh<br></code></pre></td></tr></table></figure><p>以直接指令下达的三种方式如下所示：<br></p><ul><li><p>以绝对路径的形式执行：例如指令<code>/bin/ls /etc</code>，将会列出<code>/etc</code>目录下的文件信息，前面的<code>/bin/ls</code>就是以绝对路径的形式执行了名为<code>ls</code>的脚本指令（没错，<code>ls</code>等常见的指令其实就是一个个脚本程序哦~）。<br></p></li><li><p>以相对路径的形式执行：如果你此时正处于<code>/bin</code>目录下，那么你可以直接使用指令<code>./ls /etc</code>来实现同样的功能，<code>./</code>就是“当前目录”的意思。<br>&gt;由于指令的执行需要变量（bash章节才会提到）的支持，若你的可执行文件放置在本目录，并且本目录并非正规的可执行文件目录（/bin,/usr/bin等为正规），此时要执行指令就得要严格指定该可执行文件。“./”代表“本目录”的意思，所以“./run.sh”代表“执行本目录下，名为run.sh的文件”啰！<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Linux目录配置](https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/44.html)">[3]</span></a></sup><br></p></li><li><p>利用环境变量PATH执行：透过<code>$PATH</code>这个变量的顺序搜寻到的第一个命令来运行。如果将<code>scripts.sh</code>放入<code>PATH</code>变量指定的工作目录下，我们就可以直接输入<code>scripts.sh</code>来执行这个脚本！</p></li></ul><p>当然，使用<code>alias</code>设置别名也能实现同样的效果，不过我认为这只是一个“小花招”，就没有把它列为第四种方式。<br></p><p>看到这里，有的同学可以会产生一个疑问：上面提到的<code>ls</code>等脚本指令，我在实际使用的时候都是直接使用的，根本就没有采用什么绝对路径、相对路径和所谓的PATH变量啊，那它到底是怎么执行的？<br></p><p>好，问到点子上了，我们分别看一下<code>ls</code>指令的执行顺序和<code>PATH</code>变量的具体内容：<br><img src="/img/article/art-scripts-exec/ls指令.png" alt="图2 ls指令" />了解了吗？原来<code>ls</code>指令是一个别名，而且它所存在的路径<code>/usr/bin</code>也被记录在<code>PATH</code>变量内了。（<code>/usr/bin</code>与<code>/bin</code>相当于快捷方式一样的存在；<code>--color=auto</code>这一参数选项表示对打印出来的信息加上一定的颜色区分）<br></p><h3id="以bash程序执行bash-scripts.sh与sh-scripts.sh">以bash程序执行（bashscripts.sh与sh scripts.sh）</h3><p>与上一种直接指令下达方式不同，“以bash程序执行”的的这种直接指令下达并不需要脚本程序具有可执行权限。脚本执行的方式也非常简单，如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash scripts.sh<br><span class="hljs-comment">#或者使用下面的方式</span><br>sh scripts.sh<br></code></pre></td></tr></table></figure><p>现在举个例子瞧瞧吧： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#! /bin/bash</span><br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;please input your firstname&quot;</span> fir_name<br><span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;please input your lastname&quot;</span> la_name<br><br><span class="hljs-built_in">echo</span> “your full name is <span class="hljs-variable">$&#123;fir_name&#125;</span><span class="hljs-variable">$&#123;la_name&#125;</span>”<br></code></pre></td></tr></table></figure> 最后运行的结果如下：<br></p><p><img src="/img/article/art-scripts-exec/eg1.png"alt="图3 sh02.sh在子程序内执行" />我们可以发现在脚本执行完毕后无法在父程序中打印出脚本中的两个变量。<br></p><h2 id="父程序内执行source与.">父程序内执行（source与.）</h2><p>顾名思义，以父程序内执行的形式执行脚本，那么脚本执行的环境就在父程序，就像坐高铁，一路畅通。<br>这类指令有两个，分别是<code>source</code>与<code>.</code>，使用方式如下：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> scripts.sh   <span class="hljs-comment">#scripts.sh不需要可执行权限</span><br><br>. scripts.sh        <span class="hljs-comment">#scripts.sh同样不需要可执行权限</span><br></code></pre></td></tr></table></figure><p>值得一提的是，<code>source</code>与<code>.</code>这两个都是shell自带的内建命令，这两个命令是等价的关系。也就是说这两条命令的执行是完全一样的。使用type source 和 type . 可以看出它们都是内建命令；使用 help source 和 help.也可以看出这两个命令的作用一模一样。因此，这两个命令是等价的，用哪个都行<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Linux 执行脚本时 source 和 . 和 sh 和 ./ 的区别](https://www.cnblogs.com/FengZeng666/p/15323028.html)">[4]</span></a></sup>。<br></p><figure><img src="/img/article/art-scripts-exec/父程序.png"alt="图4 scripts.sh在父程序内执行" /><figcaption aria-hidden="true">图4 scripts.sh在父程序内执行</figcaption></figure><p>我们同样使用上一个例子进行测试：<br></p><figure><img src="/img/article/art-scripts-exec/eg2.png"alt="图5 sh02.sh在父程序内执行" /><figcaption aria-hidden="true">图5 sh02.sh在父程序内执行</figcaption></figure><p>我们可以发现这次在脚本执行完毕后可以在父程序中打印出脚本中的两个变量。这也是为啥我们有时需要不注销系统而要让某些写入<code>~/.bashrc</code>的配置生效时，使用<code>source ~/.bashrc</code>而不是使用<code>sh ~/.bashrc</code><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[简单的 shell script 练习](http://cn.linux.vbird.org/linux_basic/0340bashshell-scripts_2.php)">[5]</span></a></sup>。<br></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="http://cn.linux.vbird.org/linux_basic/0320bash.php#export">认识和学习bash</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span><a href="http://cn.linux.vbird.org/linux_basic/0320bash_4.php">BashShell的操作环境</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/44.html">Linux目录配置</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span><a href="https://www.cnblogs.com/FengZeng666/p/15323028.html">Linux执行脚本时 source 和 . 和 sh 和 ./ 的区别</a><a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><ahref="http://cn.linux.vbird.org/linux_basic/0340bashshell-scripts_2.php">简单的shell script 练习</a><a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>嵌入式Linux</category>
      
      <category>[object Object]</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bash</tag>
      
      <tag>Shell</tag>
      
      <tag>Shell Scripts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux环境变量（export、echo、/etc/profile、~/.bashrc辨析）(下)</title>
    <link href="/2024/06/20/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88export%E3%80%81echo%E3%80%81-etc-profile%E3%80%81-bashrc%E8%BE%A8%E6%9E%90%EF%BC%89-%E4%B8%8B/"/>
    <url>/2024/06/20/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88export%E3%80%81echo%E3%80%81-etc-profile%E3%80%81-bashrc%E8%BE%A8%E6%9E%90%EF%BC%89-%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>在<a href=""title="https://yeyisheng.github.io/2024/06/15/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88export%E3%80%81echo%E3%80%81-etc-profile%E3%80%81-bashrc%E8%BE%A8%E6%9E%90/#">上一篇文章</a>中简要介绍了环境变量和相关指令，那么在这里就介绍一下与配置环境变量相关的配置文件。</p><p>配置文件路径均以绝对路径形式给出。</p><p><strong>版主放鸽子咯<sub>正在施工中</sub></strong></p><h1 id="bashrc">~/.bashrc</h1><h1 id="bash_profile">~/.bash_profile</h1><p>远程连接时可以使用的环境变量需要在这里设置</p><h1 id="etcprofile">/etc/profile</h1><p>该文件保存了环境变量和别名</p><h1 id="etcprofile.d.sh">/etc/profile.d/*.sh</h1><h1 id="etcbashrc">/etc/bashrc</h1><p>[https://blog.csdn.net/qq_42402648/article/details/111870238]该文件是Bash的配置文件</p><p>生效时间：新开终端生效，或者手动source /etc/bashrc生效生效期限：永久有效 生效范围：对所有用户有效</p><h1 id="etcbash.bashrc">/etc/bash.bashrc</h1><p>[https://blog.csdn.net/Zheng__Huang/article/details/107902325]</p><h1 id="etcre.local">/etc/re.local</h1><p>[https://blog.csdn.net/taoerchun/article/details/52213822]提了一嘴，没有详细介绍</p><h1 id="etcsysconfigi18n">/etc/sysconfig/i18n</h1><p>[https://www.cnblogs.com/liang-io/p/9825363.html]</p><h1 id="etcenvironment">/etc/environment</h1><p>[https://cn.linux-console.net/?p=8282]在此文件中可以配置全用户环境变量，在这里设置的环境变量，所有的用户都可以使用。</p><h1 id="etcinit.d">/etc/init.d</h1><p>[https://blog.csdn.net/weixin_42496943/article/details/104884766]init.d 目录中存放的是一系列系统服务的管理（启动与停止）脚本。用service命令可执行init.d目录中相应服务的脚本。 service httpd start</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>嵌入式Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bash</tag>
      
      <tag>Shell</tag>
      
      <tag>环境变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux环境变量（export、echo、/etc/profile、~/.bashrc辨析）(上)</title>
    <link href="/2024/06/15/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88export%E3%80%81echo%E3%80%81-etc-profile%E3%80%81-bashrc%E8%BE%A8%E6%9E%90/"/>
    <url>/2024/06/15/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88export%E3%80%81echo%E3%80%81-etc-profile%E3%80%81-bashrc%E8%BE%A8%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>由于本人遇到问题经常不求甚解，导致学艺不精。所以每次用Shell指令时，在遇到<code>export、echo、/etc/profile、~/.bashrc</code>等常见的指令和文件时都会有一种“诶好像在哪见过，但我忘了”的感觉，然后再照着教程敲命令，所谓“小和尚念经——有口无心”，正是本人了。好了，本着事不过三的原则，这次下点功夫，索性把这些东西全给他端了。</p><p>在开始之前，先介绍Linux中的一些变量，因为它们经常遇到，并且环境变量在Shell中起着举足轻重的作用。</p><h1 id="普通变量自定义变量">普通变量（自定义变量）</h1><p>我将Shell普通变量理解为C语言中变量，可以用来完成幅值、运算等操作，字符串变量还能完成拼接、打印等各种函数操作。一般来说，普通变量一般由开发者在开发脚本程序时创建，完成运算、判断等任务。例如，我创建一个名为<code>test1.sh</code>的脚本，在其中敲入以下内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">for</span> skill <span class="hljs-keyword">in</span> Ada Coffe Action Java; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;I am good at <span class="hljs-variable">$&#123;skill&#125;</span>Script&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>为其添加可执行权限后使用<code>./test1.sh</code>指令执行该脚本，输出如下：<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir">yeyisheng<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>./test1.sh <br>I am good at <span class="hljs-title class_">AdaScript</span><br>I am good at <span class="hljs-title class_">CoffeScript</span><br>I am good at <span class="hljs-title class_">ActionScript</span><br>I am good at <span class="hljs-title class_">JavaScript</span><br>yeyisheng<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~</span>$<br></code></pre></td></tr></table></figure>其中，<code>echo</code>是将内容在terminal打印出来的指令，<code>$</code>是用来获取变量值的，在这里就是获取变量<code>skill</code>的值，其两边的花括号是为了帮助解释器识别变量的边界<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[CSDN:Linux配置环境变量](https://blog.csdn.net/qq_42402648/article/details/111870238)">[1]</span></a></sup>，如果不给skill变量加花括号，写成<code>echo "I am good at skillScript"</code>,解释器就会把skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。<strong>推荐给所有变量加上花括号，这是个好的编程习惯</strong>。</p><p>需要注意的是，Bash中的变量默认都是字符串型变量，如果我们想当然地定义一个“数值变量”，并对其进行加减乘除等算数运算，会发现不能得到预期中的结果，如以下代码：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>a=123<br>b=456<br>c=<span class="hljs-variable">$a</span>+<span class="hljs-variable">$b</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$c</span><br></code></pre></td></tr></table></figure>最后打印的结果是<code>123+456</code>，如果想使变量支持数值运算，需要使用<code>declare</code>命令手动声明变量的类型<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Linux Bash Shell编程](https://blog.csdn.net/Zheng__Huang/article/details/107902325)">[2]</span></a></sup>。在这里还可以看出，声明变量时变量名与等号之间不能有等号，这可能和你熟悉的所有编程语言都不一样，等号两边的空格可能会导致错误<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Shell 变量](https://www.runoob.com/linux/linux-shell-variable.html)">[3]</span></a></sup>。</p><p><code>declare</code>的使用语法是： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">declare</span> [+/-] [选项] 变量名称<br></code></pre></td></tr></table></figure> <imgsrc="/img/article/art-export/pic1.png" alt="图1 declare参数说明" /></p><p>具体的关于Shell变量和编程方法这里就不再赘述，详情见以下三篇文章： <ahref=""title="https://blog.csdn.net/Zheng__Huang/article/details/107902325">LinuxBash Shell编程</a> <a href=""title="https://www.runoob.com/linux/linux-shell-variable.html">Shell变量</a><a href=""title="https://abcfy2.gitbooks.io/linux_basic/content/index.html">Linux基础概要</a></p><p>普通变量的生存时间有限，只能在当前脚本文件或当前Shell中使用，无法在当前Shell的子Shell中使用，因为这些变量没有添加进Shell的环境中，也就是说它们并不是环境变量。以上面的脚本为例，在脚本执行完成后，我想单独打印出a、b、c的值，却只能打印出空白：<img src="/img/article/art-export/pic5.png" alt="图2 普通变量" /></p><p><code>./</code>指令会另外打开一个Shell进行可执行文件的执行，由于a、b、c并不是环境变量，所以在其他Shell中无法使用。</p><p>关于<code>source</code>、<code>.</code>、<code>sh</code>、<code>bash</code>和<code>./</code>的辨析，可以看我的这篇文章：<ahref=""title="https://yeyisheng.github.io/2024/06/21/%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E8%BE%A8%E6%9E%90/">脚本执行指令辨析（source, . , sh , bash , ./）</a></p><h1 id="环境变量">环境变量</h1><p>当我们启动Shell的时候，会引用一组变量以<strong>确保正确配置Shell</strong>。这些变量还确保终端窗口和Shell可能需要参考的任何信息都可用。总的来说，这些变量包含定义我们在终端窗口中找到的环境的设置，从我们写完代码后调用的GCC编译器位置、Shell尝试查找命令时搜索的目录集以及我们的默认编辑器，一直到我们的语言环境、时区、键盘设置和命令提示符的外观。因此，很自然地，它们被称为环境变量<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[如何在 Linux 上的 Bash 中设置环境变量](https://cn.linux-console.net/?p=8282)">[4]</span></a></sup>。</p><h2 id="环境变量的继承">环境变量的继承</h2><p>区别于普通变量，环境变量可以在当前Shell的子Shell中继续有效，而普通变量的则无法在其子Shell中生效。（父Shell与子Shell的关系等效于<ahref=""title="https://yeyisheng.github.io/2024/06/21/%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E8%BE%A8%E6%9E%90/">脚本执行指令辨析（source, . , sh , bash , ./）</a>提到的父程序与子程序）当Shell启动时（打开Terminal或者执行某个脚本）时，它会经历一个初始化阶段，此时Shell会读取定义Shell环境的环境变量。如果在Terminal中执行一个程序、脚本或者命令时，当前Shell/进程会开辟一个子Shell/进程，子Shell会进程父进程的环境变量。</p><p>以下的几种环境变量是我在查阅资料后自己总结出的，名称也是我自己起的，严谨起见，我会在文章末尾贴出所有用到的参考网页链接</p><h2 id="全用户环境变量">全用户环境变量</h2><p>顾名思义，全用户环境变量可以被所有用户使用，以下是几种常见的全用户环境变量：</p><ul><li>SHELL： 打开终端窗口时将启动的 shell 的名称。在大多数 Linux发行版中，这将是 bash，除非您更改了默认值。</li><li>TERM：终端窗口实际上是硬件终端的模拟。这包含将要模拟的硬件终端的类型。</li><li>USER：当前使用该系统的人的用户名。</li><li>PWD：当前工作目录的路径。</li><li>OLDPWD：移动到当前工作目录之前您所在的目录。</li><li>LS_COLORS：ls 使用的颜色代码列表突出显示不同的文件类型。</li><li>MAIL：如果 mail 系统已在您的 Linux计算机上设置（默认情况下未设置），这将保存当前用户的路径邮箱。</li><li>PATH：一个目录列表，shell 将搜索这些目录以查找命令可执行文件。</li><li>LANG：语言、本地化和字符编码设置。</li><li>HOME：当前用户的主目录。</li><li><em>：下划线 (</em>) 环境变量保存最后输入的命令。</li></ul><p>如果我们需要自定义一个全用户环境变量，可以将它们添加到/etc/environment文件中。注意需要使用sudo来编辑这个文件：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>environment<br></code></pre></td></tr></table></figure>往其中添加一个名为USER1的变量，注意<strong>需要关机重启或者使用<code>source</code>指令和<code>.</code>指令该文件</strong>后才能使用这个变量：</p><figure><img src="/img/article/art-export/pic2.png"alt="图3 添加全用户环境变量" /><figcaption aria-hidden="true">图3 添加全用户环境变量</figcaption></figure><figure><img src="/img/article/art-export/pic3.png"alt="图4 用户yeyisheng使用变量" /><figcaption aria-hidden="true">图4 用户yeyisheng使用变量</figcaption></figure><p>因为它是一个全局环境变量，并且对所有人都可用，所以用户yezhixuan可以在下次登录时引用该环境变量：<img src="/img/article/art-export/pic4.png"alt="图5 用户yezhixuan使用变量" /></p><h2 id="shell环境变量">SHELL环境变量</h2><blockquote><p>这些是 <strong>bash 中用于指示或记录其行为和功能的一些 shell环境变量</strong>。一些值会在您使用终端时更新。例如，COLUMNS环境变量将被更新以反映您可能对终端窗口宽度所做的更改：</p></blockquote><ul><li>BASHOPTS：启动 bash 时使用的命令行选项。</li><li>BASH_VERSION：bash 版本号，由单词和数字组成。</li><li>BASH_VERSINFO：作为数字的 bash 版本。</li><li>COLUMNS：终端窗口的当前宽度。</li><li>DIRSTACK：已通过<code>pushd</code>命令添加到目录堆栈的目录。</li><li>HISTFILESIZE：history文件中允许的最大行数。</li><li>HISTSIZE：内存中允许的history行数。</li><li>HOSTNAME：计算机的主机名。</li><li>IFS：用于分隔命令行输入的内部字段分隔符。默认情况下，这是一个空格。</li><li>PS1:PS1环境变量包含主要提示符、默认提示符和命令提示符的定义。命令提示符的定义中可以包含一组称为转义序列的标-记。它们代表主机和用户名、当前工作目录和时间等内容。</li><li>PS2：当一条命令超过一行并且需要更多输入时，会显示辅助命令提示符。PS2环境变量保存此辅助提示的定义，默认情况下，它是大于号(&gt;)。</li><li>SHELLOPTS：可以使用<code>set</code>选项设置的Shell选项。</li><li>UID：当前用户的用户标识符。</li></ul><p>这些变量就好比是Shell的出厂说明书，告诉你Shell的配置信息和如何对其进行修改。</p><h2 id="terminal对话环境变量">Terminal对话环境变量</h2><p>Terminal对话环境变量主要是我们平时在打开Terminal之后在对话中会使用到的一些环境变量，比如在编译代码时用到的编译器的路径等等。如果只想创建单一用户使用的环境变量，而不是让计算机上的每个用户都受到某一个用户创建的环境变量的影响，我们可以在<code>.bashrc</code>（bashruntimeconfiguration，bash运行时配置文件）文件中添加属于单一用户的环境变量，该文件在用户的家目录下，文件名称最前面的<code>.</code>代表这是一个隐藏文件，我们需要使用指令<code>ls -a</code>才能查看它。<img src="/img/article/art-export/pic6.png" alt="图6 .bashrc" /></p><p>比如我在开发Qt时就在这个文件里面导入了下面几个关于环境配置的环境变量。<img src="/img/article/art-export/pic7.png"alt="图7 Qt配置的环境变量" /></p><p>事实上，<code>.bashrc</code>文件是每一位用户用来配置终端功能和属性设置的，修改<code>.bashrc</code>可以改变环境变量PATH、别名alias和提示符。Terminal使用Bash对用户输入的指令进行解释并执行，且允许使用脚本进行一定程度的自定义，这就是<code>.bashrc</code>配置文件的作用。为了加载用户<strong>首选项</strong>，<strong><code>Bash</code>在每次启动时都会自动载入<code>.bashrc</code>配置文件中的内容</strong>（无论是新打开一个Shell还是在父Shell中打开一个子Shell），它用于保存和加载不同用户的<strong>终端首选项</strong>和<strong>环境变量</strong><sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[博客园](https://www.cnblogs.com/saysmy/articles/11332411.html)">[5]</span></a></sup>。</p><p>自定义<code>.bashrc</code>配置文件的主要好处有： -添加<strong>别名</strong>可以让更快地输入和执行命令，以节省时间。 -添加<strong>函数</strong>可以保存和重复执行复杂的代码。 -可以显示有用的系统信息。 - 可以自定义 Bash 提示信息。</p><p>需要注意的是，用户对<code>.bashrc</code>所作的任何更改将在下次启动终端时生效，如果想立即生效可以手动执行<code>source</code>命令或<code>.</code>命令重新读取文件进行刷新。推荐阅读文章<ahref="" title="https://www.sysgeek.cn/bashrc/">bashrc配置文件自定义指南，如何添加别名、使用函数等</a>以便获得对<code>.bashrc</code>文件更加全面和深入的认识。</p><p>扯远了，让我们回到对话环境变量。我们分别创建一个普通变量和一个环境变量，同时我还额外创建了一个<code>SESSSION_VAR</code>变量：<img src="/img/article/art-export/pic8.png"alt="图8 验证环境变量" /></p><figure><img src="/img/article/art-export/pic9.png" alt="图9 验证环境变量" /><figcaption aria-hidden="true">图9 验证环境变量</figcaption></figure><p><code>export</code>指令用来创建能够被子Shell继承的环境变量，我将在稍后介绍这个指令。</p><blockquote><p>一个变量创建时，它不会自动地为在它之后创建的shell进程所知。而命令export可以向后面的shell传递变量的值。当一个shell脚本调用并执行时，它不会自动得到原为脚本（调用者）里定义的变量的访问权，除非这些变量已经被显式地设置为可用。export命令可以用于传递一个或多个变量的值到任何后继脚本。----《UNIX教程》</p></blockquote><p>说人话就是，变量在创建时如果不是使用<code>export</code>指令创建的，那么它就是一个普通变量，这个普通变量不能在其他Shell或当前Shell的子Shell中使用；如果使用了<code>export</code>指令创建，那么它就是一个环境变量，这个环境变量能在当前Shell的子Shell中使用。但它仍然不能在另一个Shell中使用，如果像使它在另一个Shell中使用，需要在<code>.bashrc</code>文件中<code>export</code>这个变量。</p><p>现在我们已经创建好了<code>COMMON_VAR</code>、<code>SESSION_VAR</code>和<code>INHERITED_VAR</code>这三个变量，接着我们在Terminal中将它们打印出来。<img src="/img/article/art-export/pic11.png"alt="图10 验证环境变量" /></p><p>前三个<code>echo</code>分别打印出了上面三个变量，接着我使用<code>bash</code>指令打开了一个子Shell，（由于我在.bashrc中的设置，所以每打开一个Shell都会打印出Username和Date）。可以看出，<code>INHERITED_VAR</code>和<code>SESSION_VAR</code>均可在子shell中访问，但<code>COMMON_VAR</code>不可访问。我们只是得到一个空行。<code>INHERITED_VAR</code>是因为<code>export</code>指令导入为环境变量，所以能在子Shell中使用，这个我们能够理解，但是<code>SESSION_VAR</code>并没有导入为环境变量，它为什么也能在子Shell中使用呢？这个问题留给读者自己去思考（&gt;_*。</p><p>注意，虽然<code>INHERITED_VAR</code>被<code>export</code>指令导入为环境变量，但它不是一个全用户环境变量，所以用户<code>yezhixuan</code>并不能使用它。</p><p>要关闭我们的子bash会话，我们使用<code>exit</code>： <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure></p><p>接着我们做一个有趣的小实验，创建一个名为<code>envtest.sh</code>的脚本，向其中写入如下内容：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;SESSION_VAR&quot;</span> <span class="hljs-variable">$SESSION_VAR</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;INHERITED_VAR&quot;</span> <span class="hljs-variable">$INHERITED_VAR</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;COMMON_VAR&quot;</span> <span class="hljs-variable">$COMMON_VAR</span><br></code></pre></td></tr></table></figure>分别使用<code>source</code>和<code>.</code>指令执行脚本，打印出来的内容却不大相同，为什么会这样？还记得我在上面曾说过的话吗：“<code>./</code>指令会另外打开一个Shell进行可执行文件的执行”，新打开的Shell同时丢失了<code>SESSION_VAR</code>和<code>COMMON_VAR</code>这两个变量。<img src="/img/article/art-export/pic12.png"alt="图11 验证变量的继承" /></p><p>如果我们在命令行导出这两个环境变量，然后再次运行脚本： <imgsrc="/img/article/art-export/pic13.png"alt="图12 验证脚本对变量的继承" /></p><p>环境变量已经添加到当前shell的环境中，因此它出现在脚本继承的环境中。该脚本也可以引用该环境变量。</p><h2 id="远程连接时可以使用的环境变量">远程连接时可以使用的环境变量</h2><p>我没有在远程会话中使用过环境变量，所以在这里我只是简要介绍一下。(以后如果用到了我会接着进行补充</p><blockquote><p>远程登录会话可以访问全局环境变量，但是如果您希望本地定义的环境变量可以远程使用，则必须将它们添加到.bash_profile 文件中。您可以在 .bashrc 和 .bash_profile文件中设置相同的环境变量，但值不同。这可以通过脚本获取，例如，为本地或远程使用系统的人修改其行为。</p></blockquote><p>据我的理解，如果想要在远程连接时使用环境变量，需要提前在<code>.bash_profile</code>文件中写入。而且<code>.bash_profile</code>和<code>.bashrc</code>二者相互独立，可以在<code>.bash_profile</code>和<code>.bashrc</code>文件中设置名称相同但值不同的环境变量。</p><h2id="相关指令6">相关指令<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Linux环境变量和（export，echo的使用）](https://blog.csdn.net/han_hhh/article/details/120717598)">[6]</span></a></sup></h2><h3 id="export">export</h3><p>Linux<code>export</code>命令用于设置或显示环境变量。</p><p>在 shell 中执行程序时，shell会提供一组环境变量。<code>export</code>可新增，修改或删除环境变量，供后续执行的程序使用。<code>export</code>的效力仅限于该次登陆操作<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Linux export 命令](https://www.runoob.com/linux/linux-comm-export.html)">[7]</span></a></sup>。</p><p>单独使用<code>export</code>命令会打印出当前系统定义的所有环境变量（关注红框部分的PATH变量）<img src="/img/article/art-export/pic14.png" alt="图13 export指令" />我们可以在打印出来的内容中看到诸如<code>declare -x LANG="zh_CN.UTF-8"</code>的字样，由之前我们对<code>declare</code>指令的介绍可以知道，参数x代表环境变量的意思。</p><p>使用指令<code>export PATH=$PATH:/opt</code>，再使用<code>export</code>指令查看当前系统定义的所有环境变量（关注红框部分的PATH变量，发现多了:/opt）.<img src="/img/article/art-export/pic15.png"alt="图14 export指令" /></p><h3 id="env">env</h3><p><code>env</code>指令用来显示当前用户的环境变量，但不会显示其自定义变量</p><h3 id="declare">declare</h3><p><code>declare</code>指令用来显示当前Shell中定义的所有变量，包括用户的环境变量和自定义变量，该命令的输出按变量名进行排序。</p><h3 id="set">set</h3><p><code>set</code>指令功能同<code>declare</code>一样，显示当前Shell中定义的所有变量，包括用户的环境变量和自定义变量。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://blog.csdn.net/qq_42402648/article/details/111870238">CSDN:Linux配置环境变量</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><ahref="https://blog.csdn.net/Zheng__Huang/article/details/107902325">LinuxBash Shell编程</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://www.runoob.com/linux/linux-shell-variable.html">Shell变量</a> <a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span><a href="https://cn.linux-console.net/?p=8282">如何在Linux 上的 Bash 中设置环境变量</a><a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><ahref="https://www.cnblogs.com/saysmy/articles/11332411.html">博客园</a><a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><ahref="https://blog.csdn.net/han_hhh/article/details/120717598">Linux环境变量和（export，echo的使用）</a><a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7"class="footnote-text"><span><a href="https://www.runoob.com/linux/linux-comm-export.html">Linuxexport 命令</a><a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>嵌入式Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bash</tag>
      
      <tag>Shell</tag>
      
      <tag>环境变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bash/Shell</title>
    <link href="/2024/06/14/Bash-Shell/"/>
    <url>/2024/06/14/Bash-Shell/</url>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>Shell是运行在终端中的文本互动程序，是用户与Linux内核之间的接口程序，是二者沟通的桥梁<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Shell 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/linux/linux-shell.html)">[1]</span></a></sup><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Linux(四)：什么是Bash、什么是shell？_bash shell-CSDN博客](https://blog.csdn.net/mingyuli/article/details/112420435)">[2]</span></a></sup>。<br> Shell是一个命令语言解释器（command-languageinterpreter）。拥有自己内建的shell命令集。此外，Shell也能被系统中其他有效的Linux实用程序和应用程序（utilitiesand application programs）所调用。<br>不论何时你键入一个命令，它都被Linuxshell所解释。一些命令，比如打印当前工作目录命令（pwd），是<strong>包含在Linuxbash内部的</strong>（就象DOS的内部命令）。其他命令，比如拷贝命令（<code>cp</code>）和移动命令（<code>rm</code>），<strong>是存在于文件系统中某个目录下的单独的程序</strong>。而对用户来说，你不知道（或者可能不关心）一个命令是建立在Shell内部还是一个单独的程序<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Shell | Linux基础概要 (gitbooks.io)](https://abcfy2.gitbooks.io/linux_basic/content/first_sense_for_linux/shell/index.html)">[3]</span></a></sup>。<br><img src="/img/article/art-bash/pic1.png" alt="图1 shell" /></p><p>Linux的Shell种类众多，常见的有：</p><ul><li>Bourne Shell（/usr/bin/sh或/bin/sh，已经被 /bin/bash 所取代）</li><li>Bourne Again Shell（/bin/bash，就是 Linux 默认的 shell）</li><li>C Shell（/usr/bin/csh，已经被 /bin/tcsh 所取代，整合了 C Shell，提供更多的功能）</li><li>K Shell（/usr/bin/ksh，Kornshell 由 AT&amp;T Bell lab.发展出来的，兼容于 bash）</li><li>Z Shell（基于 ksh 发展出来的，功能更强大的 shell）</li><li>Shell for Root（/sbin/sh） <br></li></ul><p>Bash（GNU Bourne-Again Shell）是最常用的一种Shell，它是sh（BourneShell）的改进版，其中Bourne就是sh的作者。Bash是当前大多数Linux发行版的默认Shell，可以说，Bash之于Shell就如同Ubuntu之于Linux<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[知乎 (zhihu.com)](https://www.zhihu.com/question/40448945)">[4]</span></a></sup>。<br>使用指令<code>cat /etc/shells</code>指令来查看当前Linux系统的可用Shell。（之所以会有这样一个文件来记录系统的可用Shell，是因为系统某些服务在运行过程中，会去检查用户能够使用的shells ，而这些shell的查询就是藉由 /etc/shells 这个文件实现）<br> <imgsrc="/img/article/art-bash/pic2.png" alt="图2 查看可用shell" /></p><p>使用指令<code>echo $SHELL</code>查看当前系统所使用的Shell种类，比如我系统中使用的就是Bash。<br><img src="/img/article/art-bash/pic3.png"alt="图3 查看当前系统使用的shell" /></p><p>Bash能够作为所有Linux发行版的默认Shell，离不开它的以下几个优点<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[鸟叔的Linux私房菜：基础版](http://cn.linux.vbird.org/linux_basic/0320bash_1.php)">[10]</span></a></sup>：<br>- 命令记忆功能（history）通过按下键盘的上下键就能够找到曾经输入的所有指令，相信曾为你提供不少的便利。在大多数Linux发行版中，能够记忆的指令高达100条，这些指令都被记录在家目录下的/bash_history中，不过此文件中记录的是上一次登录所使用过的指令；- 命令与文件名称补全（Tab按键的妙用） 这也是BashShell提供的非常棒的功能，为我们省去了背诵各种繁杂指令和文件名称的功夫，我们只需要记住命令开头几个字母按下Tab键就能自动补全名称或者显示所有可运行指令；- 别名配置（alias）很多朋友喜欢使用的<code>ll</code>指令其实是<code>ls -al</code>的别名，可能他们还不自知（嘻嘻，想知道你的系统中使用了那些别名？在终端中键入<code>alias</code>试试看吧！- 工作控制、前景背景控制： (job control, foreground, background)这个我不了解，详情请查看参考文献； - 程序化脚本： (shell scripts)将你平时管理系统常需要下达的连续命令写成一个脚本文件，该脚本可以通过对话交互式的方式来进行主机的侦测工作！整个设计下来几乎就是一个小型的程序语言；- 通配符： (Wildcard)通配符可以帮助用户查询与命令下达，举例来说，想要知道<code>/usr/bin</code>底下有多少以X 为开头的文件吗？使用：<code>ls -l /usr/bin/X*</code>就可以知道了。</p><h2 id="shell中执行命令的方式">Shell中执行命令的方式</h2><p>Shell有两种执行命令的方式：<br>(1)交互式（Interactive）：解释执行用户的命令，用户输入一条命令，Shell就解释执行一条。比如我们平时经常在terminal命令行使用<code>cd、pwd、mv、cp、tar</code>等命令，都属于此种方式。<br>(2)批处理（Batch）：用户事先写一个Shell脚本(Script)如.sh文件，其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。<br>在使用交互式方法执行Shell命令时，通常有一些重要的快捷键需要我们掌握，掌握它们可以让我们执行命令时事半功倍。<br><img src="/img/article/art-bash/pic4.png"alt="图4 Terminal快捷键" /></p><h2 id="shell中命令的种类">Shell中命令的种类</h2><p>Shell中命令有三类<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Bash编程入门-1：Shell与Bash - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/56532223)">[5]</span></a></sup>，分别是：<br>(1)内建（built-in）命令：是Shell程序的一部分，写在bash的源码<code>builtins</code>里面的，通常在Shell程序被加载驻留在系统内存中，解析内部命令不需要创建子进程，因此执行速度快于下面的外部命令，比如<code>history、cd、exit</code><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Linux：帮助命令——help、man、info的简单介绍_linux help - man-CSDN博客](https://blog.csdn.net/m0_56238419/article/details/123912800)">[6]</span></a></sup>，使用<code>help</code>即可列出所有内建命令，也可以使用<code>help COMMAND</code>查看内建函数的详细介绍；<br><img src="/img/article/art-bash/pic5.png"alt="图5 查看Shell所有内建命令" /></p><p>(2)外部命令：保存在shell之外的脚本，提供了额外的功能，是Linux实用程序的一部分，功能比较强大，不随系统一起被加载到内存中，外部命令虽然不在Shell中，但其命令的调用时由shell程序控制的，外部命令是在bash之后额外安装的，通常放在<code>/bin，/usr/bin，/sbin，/usr/sbin</code>等等。比如：<code>ls</code>、<code>vi</code>等；<br>(3)别名(alias)：给某个命令的简称。<br> <imgsrc="/img/article/art-bash/pic6.png" alt="图6 查看Shell命令种类" /></p><p>需要注意的是<code>help</code>命令不带任何参数的话只用于显示内建命令的帮助信息，包括一些简要说明以及一些参数的使用以及说明，如果加上<code>--help</code>的参数就可以查看外部命令的帮助信息了。<br><img src="/img/article/art-bash/pic7.png"alt="图7 使用help查看命令介绍" /></p><p>如果想查看更加详细的命令介绍，可以使用<code>man</code>，比<code>help</code>更加详细，而且无内建命令和外部命令之分，<code>man</code>好比一个电子词典，里面多是对命令的详细解释信息，<code>help</code>适合在紧急是忘记用哪个参数的时候用，不太紧急的适合可以用<code>man</code><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Linux：帮助命令——help、man、info的简单介绍_linux help - man-CSDN博客](https://blog.csdn.net/m0_56238419/article/details/123912800)">[6]</span></a></sup>。<br>&gt; 比man更详细的帮助手册——info。<br></p><h2id="shell编程7">Shell编程<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[shell学习教程(超详细完整)_shell教程-CSDN博客](https://blog.csdn.net/w918589859/article/details/108752592)">[7]</span></a></sup></h2><p>在第二小节<ahref="#shell中执行命令的方式">Shell中执行命令的方式</a>中提到了批处理的方式执行Shell命令，这就涉及到Shell编程了，值得一提的是，业界所说的Shell通常都是指Shell脚本（script），但读者朋友要知道，Shell和Shellscript是两个不同的概念。由于习惯的原因，简洁起见，本文出现的"shell编程"都是指Shell脚本编程，不是指开发Shell自身。<br>Shell脚本以.sh后缀结尾，使用<code>vi/vim</code>或<code>touch</code>创建test.sh文件，并使用<code>vi/vim</code>编辑，敲入一些代码，第一行一般为<code>#!/bin/bash</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is test&quot;</span><br></code></pre></td></tr></table></figure></p><p><code>#!</code>是一个约定的标记，告诉系统其后路径所指定的程序即是解释此脚本文件的Shell程序。我们在第一小节<ahref="#简介">简介</a> 中提到shell又分很多种类，其中Bash（Bourne AgainShell）是最广泛使用的一种shell。在一般情况下，人们并不区分BourneShell和Bourne AgainShell，所以，像<code>#!/bin/sh</code>，它同样也可以改为<code>#!/bin/bash</code>。<br>完成编写后，保存退出，并使用<code>chmod 777 test.sh</code>使其具有可执行权限，这样，我们的第一个Shell脚本就编写完成了。使用<code>./test.sh</code>就可以执行此脚本，可以看出会在terminal打印出“Thisis test”字符串。<br></p><h2 id="bash常见指令">Bash常见指令</h2><ul><li>alias: 设置bash别名；</li><li>bg: 使一个被挂起的进程在后台继续执行；</li><li>cd: 改变当前工作目录；</li><li>exit: 终止shell；</li><li>export: 使变量的值对当前shell的所有子进程都可见；</li><li>fc: 用来编辑历史命令列表里的命令；</li><li>fg: 使一个被挂起的进程在前台继续执行；</li><li>help: 显示bash内部命令的帮助信息；</li><li>kill: 终止某个进程；</li><li>pwd: 显示当前工作目录；</li><li>unalias: 删除已定义的别名。</li></ul><h2id="bash常见环境变量在etcprofile文件中配置">Bash常见环境变量（在/etc/profile文件中配置）</h2><p>这里是几个最有用的环境变量，包括变量名和简单描述：<br></p><ul><li>EDITOR, FCEDIT: bash fc 命令的缺省编辑器；</li><li>HISTFILE: 用于贮存历史命令的文件；</li><li>HISTSIZE:历史命令列表的大小，表明可以存储多少条历史指令，默认是1000条；</li><li>PWD: 当前工作目录；</li><li>PATH：预设可执行文件或命令的搜索路径。<code>env</code>命令显示所有的环境变量。环境变量以<code>:</code>分开。环境变量名前<code>$</code>符号表示该变量本次定义之-前的值。由于文件的搜寻是依序由 PATH的变量内的目录来查询，所以，目录的顺序也很重要；</li><li>USER: 用户登录时使用的用户名；</li><li>HOME：当前用户主目录；</li><li>LANG/LANGUGE：这个很重要，表示语系，很多信息都会用到他，举例来说，当我们在启动某些 perl的程序语言文件时，他会主动的去分析语系数据文件，如果发现有他无法解析的编码语系，可能会产生错误！一般来说，我们中文编码通常是zh_TW.Big5 或者是zh_TW.UTF-8，这两个编码偏偏不容易被解译出来，所以有的时候，可能需要修订一下语系数据；</li><li>SHELL：是指当前用户用的是哪种Shell。<code>set</code>命令显示所有本地定义的Shell变量，包括环境变量和自定义变量，而前面提到的<code>env</code>指令只会显示环境变量；</li><li>LOGNAME：指当前用户的登录名。其值为<code>$USER</code>；</li><li>HOSTNAME：所使用的主机名。供应用程序使用；</li><li>PS1：命令行的一级提示符（格数如下，用法如右）：<code>export PS1="[\u@\h \w]\$"</code><sup id="fnref:8" class="footnote-ref"><a href="#fn:8" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[linux shell中环境变量$PS1详解-CSDN博客](https://blog.csdn.net/ishulei/article/details/108826516)">[8]</span></a></sup>；<code>\d</code>代表日期，格式为weekday month date，例如：Wed Dec12；<br><code>\H</code>完整的主机名称。例如：hostname是debian.linux；<br><code>\h</code>仅取主机的第一个名字，如上例，则为debian，.linux则被省略；<br><code>\t</code>显示时间为24小时格式，如：HH：MM：SS；<br><code>\T</code>显示时间为12小时格式；<br><code>\A</code>显示时间为24小时格式：HH：MM；<br><code>\u</code>当前用户的账号名称 如：root；<br><code>\v</code>BASH的版本信息  如:3.2；<br><code>\w</code>完整的工作目录名称。家目录会以<code>~</code>代替如显示<code>/etc/default/</code>；<br><code>\W</code>利用basename取得工作目录名称，只会列出最后一个目录。如上例则只显示default；<br><code>\#</code>下达的第几个命令；<br><code>\$</code>提示字符，如果是root时，提示符为：<code>#</code>，普通用户则为：<code>$ </code>；<br></li><li>PS2：命令行的二级提示符，默认为<code>&gt;</code><sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[BASH脚本基础：环境变量PS2介绍_shell ps2是什么-CSDN博客](https://blog.csdn.net/liumiaocn/article/details/104110665)">[9]</span></a></sup>；</li><li>MAIL： 存放用户电子邮件的邮箱（ASCII码文件）；</li><li>INPUTRC: 存放的是针对键盘热键的信息（ASCII码文件）；</li><li>$：代表目前这个 Shell 的线程代号，即所谓的 PID (Process ID)</li><li>?：代表上一个运行的命令所回传的值</li></ul><p>在这里对PS1这个变量进行进一步的解释，PS1这个变量就是用来定义每次使用终端时前面那一行的样式的，比如在这里定义的样式为<code>yeyisheng@ubuntu:~$</code><br><img src="/img/article/art-bash/pic8.png" alt="图8 PS1作用的结果" /></p><p>注意，如果在shell中修改该变量的值，只是临时生效的，一旦注销或重启系统就会消失。要想永久生效，必须写入环境变量配置文件</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span><a href="https://www.runoob.com/linux/linux-shell.html">Shell教程 | 菜鸟教程 (runoob.com)</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><ahref="https://blog.csdn.net/mingyuli/article/details/112420435">Linux(四)：什么是Bash、什么是shell？_bashshell-CSDN博客</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://abcfy2.gitbooks.io/linux_basic/content/first_sense_for_linux/shell/index.html">Shell| Linux基础概要 (gitbooks.io)</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4"class="footnote-text"><span><a href="https://www.zhihu.com/question/40448945">知乎(zhihu.com)</a><a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><ahref="https://zhuanlan.zhihu.com/p/56532223">Bash编程入门-1：Shell与Bash- 知乎 (zhihu.com)</a><a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><ahref="https://blog.csdn.net/m0_56238419/article/details/123912800">Linux：帮助命令——help、man、info的简单介绍_linuxhelp - man-CSDN博客</a><a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span><ahref="https://blog.csdn.net/w918589859/article/details/108752592">shell学习教程(超详细完整)_shell教程-CSDN博客</a><a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:8" class="footnote-text"><span><ahref="https://blog.csdn.net/ishulei/article/details/108826516">linuxshell中环境变量$PS1详解-CSDN博客</a><a href="#fnref:8" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:9" class="footnote-text"><span><ahref="https://blog.csdn.net/liumiaocn/article/details/104110665">BASH脚本基础：环境变量PS2介绍_shellps2是什么-CSDN博客</a><a href="#fnref:9" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:10" class="footnote-text"><span><ahref="http://cn.linux.vbird.org/linux_basic/0320bash_1.php">鸟叔的Linux私房菜：基础版</a><a href="#fnref:10" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>嵌入式Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bash</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于腾讯云，为Fluid博客配置Twikoo评论系统</title>
    <link href="/2024/05/06/%E5%9F%BA%E4%BA%8E%E8%85%BE%E8%AE%AF%E4%BA%91%EF%BC%8C%E4%B8%BAFluid%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AETwikoo%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/05/06/%E5%9F%BA%E4%BA%8E%E8%85%BE%E8%AE%AF%E4%BA%91%EF%BC%8C%E4%B8%BAFluid%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AETwikoo%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>本文在参考了<ahref="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">HexoFulid用户手册</a>中的<strong>评论</strong>小节和<ahref="https://twikoo.js.org/backend.html#hugging-face-%E9%83%A8%E7%BD%B2">Twikoo文档</a>中的<del><strong>HuggingFace部署</strong></del>相关小节的前提下成功为博客搭建了评论系统。下面将简要介绍整个部署过程：<br> 正如Twikoo首页所写的： <br></p><blockquote><p>一个简洁、安全、免费的静态网站评论系统。</p></blockquote><p>简约的设计和简便的部署方式让我在一开始就选择使用这种方式部署评论系统。搭建Twikoo分为两步：<br></p><ul><li>配置云函数；</li><li>在本地博客主题中配置Twikoo。</li></ul><p>让我们开始吧！<br></p><h4 id="部署云函数">部署云函数</h4><p>部署云函数时，我采取的方案是有充足的免费额度且中国大陆访问速度较快的HuggingFace和Netlify这两种部署方案。</p><h5 id="基于hugging-face">基于Hugging Face <br></h5><p>我最开始就是使用的huggingface部署的云函数，步骤完全参考<ahref="https://twikoo.js.org/backend.html#hugging-face-%E9%83%A8%E7%BD%B2">Twikoo文档</a>，我将其归为以下两步：<br>1.部署数据库，参考文档中使用的数据库是MongoDB平台2.基于huggingface部署云函数，在部署完毕后会生成一个环境id，如图1所示，图中的<strong>DirectURL</strong>就是环境id。我们将在<strong>配置本地yml文件</strong>中用到<img src="/img/article/art9/enVid.png" alt="图 1 环境id" /></p><h5 id="基于netfily">基于Netfily</h5><p>最开始我是使用了HuggingFace部署的云函数，本来都已经把评论系统搭建好了的。但是我后来想加一个邮件通知的功能，在<strong>开启邮件通知</strong>里发送测试邮件时一直提示“测试结果：{"result":{"message":"SMTP邮箱配置异常：Connectiontimeout"}}”，一查才发现huggingface限制了容器发送邮件的能力<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[在huggingface部署的无论怎么设置邮件通知测试都是提示 SMTP 邮箱配置异常](https://github.com/twikoojs/twikoo/discussions/643)">[1]</span></a></sup>，遂使用Netlify部署数据库。注意：在创建Netlify账号时，<strong>最好先停掉代理，否则会注册失败</strong>，好像是会触发身份审核<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[V2EX:你们注册的 netlify 需要身份验证么?](https://www.v2ex.com/t/970267)">[2]</span></a></sup>。但是停掉代理之后好像又不能访问Netlify注册网站了，无解了属于是。我是如何解决的呢？说来好笑，本来我是开着代理创建我的Netlify账号，我想使用github账号进行注册，但由于我忘记及时在邮箱中点击验证邮件导致我的github注册失败了，弹出了图2这个图，说我验证失败了。然后我又使用邮箱注册，但是它一直不给我发邮件，我猜测我的邮箱被它识别为垃圾邮箱了。本来我是准备放弃的，后来我在Netlify的Q&amp;A网页中<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[https://answers.netlify.com/](https://answers.netlify.com/t/authentication-error-authenticating-failed-due-to-the-following-error-your-account-requires-additional-verification-i-have-not-receive-the-verification-link/113382)">[3]</span></a></sup>看到好多人也有这个问题，我也准备提问，在发布问题的时候它提示我需要登录才能提问，然后我在这个网页里面使用邮箱注册了成功了。。。正当我满心欢喜地准备登入Netlify时，才发现我刚刚注册的是Netlify论坛的账号，并不能在这里使用，，，<img src="/img/article/art9/error1.png" alt="图 2 error1" />最后我选择换一个邮箱进行注册，我使用了网易邮箱进行注册，然后在验证身份的时候又遇到了验证不通过的问题，，，如图3，我只能在论坛中求助管理员<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[We were unable to verify your identity and reinstate your Netlify account](https://answers.netlify.com/t/we-were-unable-to-verify-your-identity-and-reinstate-your-netlify-account/115468/19)">[4]</span></a></sup>，请管理员帮忙通过验证。<img src="/img/article/art9/error2.png" alt="图 3 error2" /></p><h4 id="配置本地yml文件">配置本地yml文件</h4><p>在<strong>主题配置文件</strong>中开启Twikoo评论系统，具体路径为/themes/fluid/_cnfig.yml1.将comments下的type设置为twikoo <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">comments:</span><br>   <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>   <span class="hljs-comment"># 指定的插件，需要同时设置对应插件的必要参数</span><br>   <span class="hljs-comment"># The specified plugin needs to set the necessary parameters at the same time</span><br>   <span class="hljs-comment"># Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis | giscus</span><br>   <span class="hljs-attr">type:</span> <span class="hljs-string">twikoo</span><br></code></pre></td></tr></table></figure>2.配置twikoo评论模块参数，这里的enVId就是图1中的<strong>DirectURL</strong>，将其复制到这里就可以了。 <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Twikoo</span><br><span class="hljs-comment"># 基于腾讯云开发</span><br><span class="hljs-comment"># Based on Tencent CloudBase</span><br><span class="hljs-comment"># See: https://twikoo.js.org</span><br><span class="hljs-attr">twikoo:</span><br>  <span class="hljs-attr">envId:</span> <br>  <span class="hljs-attr">region:</span> <span class="hljs-string">ap-shanghai</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">window.location.pathname</span><br></code></pre></td></tr></table></figure>到这里，一个不影响使用的评论系统就搭建起来了，如果想追求更好的体验，比如当有人评论时即时通知或邮件通知博主，可以接着看下面的步骤。</p><h4 id="开启即时通知">开启即时通知</h4><h4 id="开启邮件通知">开启邮件通知</h4><h4 id="参考网址">参考网址</h4><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://github.com/twikoojs/twikoo/discussions/643">在huggingface部署的无论怎么设置邮件通知测试都是提示SMTP 邮箱配置异常</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span><a href="https://www.v2ex.com/t/970267">V2EX:你们注册的netlify 需要身份验证么?</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://answers.netlify.com/t/authentication-error-authenticating-failed-due-to-the-following-error-your-account-requires-additional-verification-i-have-not-receive-the-verification-link/113382">https://answers.netlify.com/</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><ahref="https://answers.netlify.com/t/we-were-unable-to-verify-your-identity-and-reinstate-your-netlify-account/115468/19">Wewere unable to verify your identity and reinstate your Netlifyaccount</a> <a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网页部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>菊次郎，你也垂垂老矣</title>
    <link href="/2024/01/07/%E8%8F%8A%E6%AC%A1%E9%83%8E%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%9E%82%E5%9E%82%E8%80%81%E7%9F%A3/"/>
    <url>/2024/01/07/%E8%8F%8A%E6%AC%A1%E9%83%8E%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%9E%82%E5%9E%82%E8%80%81%E7%9F%A3/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">            菊次郎没有暑假作业，所以暑假过得很快 </code></pre><p>2021.9.16<br> 是周四下午，在C403自习。<br>慵懒，困倦裹挟着我。无心学习，塞上耳机，浸淫不已。<br>冷不丁蹦出一首久石让的summer，心一惊：莫不是最近练这曲子被音乐软件监听到了？想想也是，变调一夹，呕哑嘲哳，神仙都救不回来。估计软件也听不下去了，推了这首原版好让我迷途知返。呵呵，不存在的，除非把我琴砸了。（砸了我再借室友的，，，）<br>曲未过半，揉碎了桌上的模电，运放与三极管都圈不住我的思绪，如同杂乱无章的载流子胡乱碰撞，飘飞到五六年前那个热烈而盛大的夏天。<br>“老杨，我来找你！你妈在家吗？” <br> “来，不在！” <br> “把大勇喊上？”<br> “嗯” <br>那时都还没有手机，三个人，挤在书房里，一旁的风扇吱呀作响，电脑开着坦克大战，也不知主机里的数字信号，怎么就随机到了这首summer。激荡、共鸣，一串串成谐波关系的傅立叶信号在我脑海里交叠、归一。同一串信号，跨越了两千多个日夜，连接过去和未来，在六年的时间之海里穿梭，竟带给我说不出的感动。好像你无意间在书桌里翻出一件笨拙的手工，嘲弄之余，又想到当初小心摆弄时的艰辛、被剪刀划破手指时的痛楚、以及叠上最后一折时，那小小心灵里的兴奋与雀跃，依然历历在目，却又怅然若失。<br> “诶你别说，这歌怪好听的” <br>“听着挺活泼，却莫名有一种怀旧的感觉，说不定以后再听这首歌的时候，还会想起我们夏天的经历呢”<br> “诶呦呦，老李，你这人就爱开玩笑” <br>“好家伙，跟踪导弹是吧，有本事别用鼠标！” <br>我本以为是一句玩笑，经不住时间的打磨。可是，六年后的某天，在某个不知名的午后，熟悉的音符闯入，记忆如上了发条般准时，倾泻而下，涌入我未来的无数个日夜，或是滴水成冰的九冬，或是烈炎灼髓的三伏，也不知这记忆中尚需呵护的夏天，还能慰藉我多少感伤的岁月。<br>记忆里的夏天是旧椅老树抱西瓜，嘴角挂着淌下的瓜汁；是蝉鸣和着路边小贩的吆喝，搅动了甜腻的糖水；是树下老人的棋局，轻轻晃悠的蒲扇，震得开裂的棋子，在皲纹苍黄的楚河汉界上排兵布阵、剑气纵横，似乎有几分漫漫黄沙、金戈铁马的韵味。<br> “老张，你又耍赖，藏我車你还，当我瞎？这局不算，重来！” <br>白衣苍狗，流年经转，树下人影掠逝，来去匆匆，也不知最后那老张头，后来又赢了几局？可惜，残局、破局，乃至败局，犹能重开，可我弄丢的那些夏天，却再也找不回来。<br>仔细一想，真的是我把夏天弄丢了吗？我不知多少次梦到我又紧握笔杆，埋头在紧张的考场，我会为填错一个选项懊恼，会在铃声敲响时惊醒，黄粱一梦，仓惶醒来，匆忙洗一把脸，穿衣准备去学校，找了半天却找不到课本和双肩包，才恍惚想起自己在多年前明眀没有做好准备，就被推搡着长大成人，像是九月的某天，夏天的味道还未褪散，突然感知到河岸的风带来凉意，抬头瞥见几片染黄的树叶，它意味着爱慕的心绪不了了之，没牵到的手，未送出的信，青春潦草收场后关上了门。<br>哈，搞半天是夏天丢下了我，可惜还没来得及跟夏天挥手告别那仓促的人生，眨眼便落入了平庸之海。我想追上那些夕阳，追上记忆里人头攒动的操场，摇摆不定的秋千，和我怎么都攀不上去的单杠，但我追不上了，人类终究是有极限的。逝川与流光，飘忽不相待，岁月飞跑，一把短藏刀，我一生的好时光引颈就戮，这路遥马急的人间，又经得住几个六年之约？假如真能重来一次，我会鼓起勇气，向那个如紫罗兰花瓣般飘动的女孩勇敢诉说吗？可能还是不会吧，少年侠骨香，纵然有睥睨万物的傲气，依旧未褪尽孩童的稚嫩。<br>我依然能够听到窗外聒噪的蝉鸣，却无法置身朗朗书声的课堂；我也能看见裹满阳光的课桌，但人面早已不知何处去；我走过很多华灯初上，人影流梭的街口，终究忘不掉无数次晚修后，跑道上逐闹的人群，和陪我走过一圈又一圈的那个人。<br>经历愈多，愈是感到自己的平凡与渺小，六年前总想生如夏花般绚烂，六年后发觉平凡才是唯一的答案。谁赏江上明月，谁闻江声浩荡，不过是渺渺天地一白丁，纵然心路八千里，胸怀云与月，奈何囿于条条框框，无论最开始如何的降心相从和单刀直入，纵横八方走不出一个人字。我做不到东坡那般出世——一蓑烟雨、袖手何妨闲处看，用舍由时？行藏在我?达咩！<br>哈哈哈，说多了，确实有些感伤了，打起精神！世路无穷，劳生有限，似此区区长鲜欢！<br></p>]]></content>
    
    
    <categories>
      
      <category>絮言碎笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>无病呻吟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>群时延相时延</title>
    <link href="/2023/05/08/%E7%BE%A4%E6%97%B6%E5%BB%B6%E7%9B%B8%E6%97%B6%E5%BB%B6/"/>
    <url>/2023/05/08/%E7%BE%A4%E6%97%B6%E5%BB%B6%E7%9B%B8%E6%97%B6%E5%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="引子咋又是你群时延">引子：咋又是你，群时延？</h2><p>今天在看通信原理时，又碰到了群时延这个老朋友，之前在看信号与系统与射频集成电路基础时就没怎么弄明白，今儿个又让我给遇上了，俗话说再一再二不再三，今天必须把它给解决掉。查了很多资料，又翻出了之前信号与系统，写得那叫一个obscure，又费了很大功夫查资料，终于弄明白了。<br></p><h2 id="辨析好像有个弟弟叫相时延">辨析：好像有个弟弟叫相时延？</h2><p>首先要明确的概念是，时延代表的含义是什么——时间上的延迟。那么时间与相位又该如何联系上？我们很自然地联想到时间与相位之间的关系：<br> <span class="math display">\[\theta = \omega·t\]</span> 式中<spanclass="math inline">\(\theta\)</span>代表相位，单位rad；<spanclass="math inline">\(\omega\)</span>代表角频率，单位rad/s；t代表时间，单位s。我们把<spanclass="math inline">\(\Delta\theta=\theta\left(t_1\right)-\theta\left(t_2\right)=\omega\left(t_1-t_2\right)\)</span>称为相位延迟（相移，phaseshift），用<spanclass="math inline">\(\varphi\left(\omega\right)\)</span>、∠Hjω表示，单位是rad；将<spanclass="math inline">\(-\frac{\varphi\left(\omega\right)}{\omega}\)</span>、<spanclass="math inline">\(-\frac{\angleH\left(j\omega\right)}{\omega}\)</span>称为相位延时（相时延，phasedelay），用<spanclass="math inline">\(P\left(\omega\right)\)</span>表示，单位是s。既然相时延的公式中又有相位，又有频率，又涉及到斜率，可以使用bode图来清晰查看相时延，因为系统相频响应的bode图横坐标就是<spanclass="math inline">\(\omega\)</span>，纵坐标就是<spanclass="math inline">\(\angleH\left(j\omega\right)\)</span>。考虑以下两种系统的相频响应bode图：<br></p><p><img src="/img/article/art7/1.png" alt="图 1 线性相位系统" /> <imgsrc="/img/article/art7/2.png" alt="图 2 非线性相位系统" /></p><p>可以看出，对于图1所示线性相位系统，还好说，其相频响应bode图斜率的相反数就是相时延，一旦迁移到非线性相位系统，相时延<spanclass="math inline">\(P\left(\omega\right)=-\frac{\angleH\left(j\omega\right)}{\omega}\)</span>似乎就没什么实际意义了，可是转念一想：诶呀，群时延是线性相位系统bode图的斜率，那我只要再弄一个非线性系统bode图的斜率不就好了？图像斜率用什么表示？不就是微分嘛。于是乎，群时延的概念应运而生，定义群时延：<br> <span class="math display">\[\tau(\omega) = -\frac{d\angle H(j\omega)}{d\omega}\]</span></p><p><font color = #ff0000>表示信号经过系统后，对于信号处于不同频率成分<spanclass="math inline">\(\mathbf{\omega}\)</span>的分量，它们各自的相位所经历的时间上的延时。</font><br>从上述定义我们可以看出，相时延就是群时延在线性相位系统下的特殊情况，也就是相频响应bode图斜率为定值，此时<spanclass="math inline">\(-\frac{d\angleH\left(j\omega\right)}{d\omega}=-\frac{\angleH\left(j\omega\right)}{\omega}\)</span>。写到这里，不由得想起来初中对速率的定义是<spanclass="math inline">\(v=\frac{s}{t}\)</span>，而上了高中，学了微积分之后，速率的定义式就变成：<spanclass="math inline">\(v=\frac{ds}{dt}\)</span>，原来是因为初中研究的都是恒速率简单运动，而高中研究的就是稍复杂些的变速率运动，于是乎，前者对速率的定义不再适用（或者说变成了平均速率），后者对速率的定义更为精确（也就是瞬时速率）。所以说，相时延与群时延的区别就好比平均速率与瞬时速率之间的区别，这么一说是不是好懂了许多？<br></p><h2 id="缘由为什么需要群时延">缘由：为什么需要群时延</h2><p>有了上面对群时延的定义，我们不经联想到：啥啊这是？一上来就噼里啪啦一堆定义，干啥玩意啊，有啥用啊？那当然是研究一个信号经过系统后的失真情况。<br>我们考虑一个方波，如果是一个连续时间周期信号，那么它是由无数个复指数信号（正弦波）叠加而成（连续时间周期信号的傅里叶级数是一般一个周期序列，这里不详细展开，详见《信号与系统》）。那么这些复指数信号在通过一个系统后，要想输出还是一个方波，即形状不发生改变，就要求它们在时域上的<font color = #ff0000>相对位置</font>不能变化，也就是<font color = #ff0000>所有频率的波的延迟时间一致</font>。等会，“所有频率的波的延迟时间”，不就是群时延的定义吗？<br>音乐厅中，我们希望不同频率声音到达听众耳朵的时间延迟是相等的，以减小声音的失真此时就要求线性相位系统；雷达系统中，回波信号的处理若不满足线性相位，则会给举例计算带来误差。<br>如果系统对所有的频率分量都有相同的相位延时（线性相位系统，此时群时延等于相时延，相频响应曲线为一条直线），那么信号经过该系统后，波形不发生失真，只是有一定的延时。但如果不同频率分量有不同的相位延时（非线性相位系统），那么信号经过该系统后将产生失真。当然这里所说的失真是指相位失真，如果信号还想要不发生幅度失真，那么它的幅频响应也得是一条水平直线才行。<br></p><p>注： <br> 数字角频率<spanclass="math inline">\(\omega\)</span>等于模拟角频率<spanclass="math inline">\(\Omega\)</span>对采样频率<spanclass="math inline">\(f_s\)</span>归一化，即：1 <spanclass="math inline">\(\omega=\frac{\Omega}{f_s}=\OmegaT_s\)</span>，单位rad；其中<spanclass="math inline">\(T_s\)</span>为采样周期，单位s；<spanclass="math inline">\(\Omega=2\pi f\)</span>，单位rad/s；</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>通信原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念辨析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MATLAB求解函数最值</title>
    <link href="/2023/05/07/MATLAB%E6%B1%82%E8%A7%A3%E5%87%BD%E6%95%B0%E6%9C%80%E5%80%BC/"/>
    <url>/2023/05/07/MATLAB%E6%B1%82%E8%A7%A3%E5%87%BD%E6%95%B0%E6%9C%80%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/article/art6/1.png" alt="图 1 通信原理例题" />如图，第一问在求解抽样信号的量化编码时，首先要将抽样信号幅值用信号最大幅值归一化。答案公式使用了<spanclass="math inline">\(I_s=\frac{0.546875}{10}\)</span>，但明眼人一看就感觉f(t)的幅值不是10V。虽然说我理解在这里使用10V作为输入信号幅值是为了简化运算，但本着爱钻牛角尖精益求精的精神，我想着求一下f(t)的幅值。（我是真的闲啊，是不是忘了明天考嵌入式，再过一周考数字信号处理和通信原理？）对于f(t)=，，，，，显然直接求导找驻点，然后代入验证极值就可以得到最值，但我不想手算，直接上MATLAB，谁叫它是宇宙第一（maybe？）数学工具呢。<br> 先绘个图，探探虚实 <br></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x<br>y = <span class="hljs-number">10</span>*<span class="hljs-built_in">sin</span>(<span class="hljs-number">4</span>*<span class="hljs-built_in">pi</span>*x)+<span class="hljs-built_in">sin</span>(<span class="hljs-number">8</span>*<span class="hljs-built_in">pi</span>*x);<br>y1 =  <span class="hljs-number">10</span>*<span class="hljs-built_in">sin</span>(<span class="hljs-number">4</span>*<span class="hljs-built_in">pi</span>*x);<br>y2 =  <span class="hljs-built_in">sin</span>(<span class="hljs-number">8</span>*<span class="hljs-built_in">pi</span>*x);<br>fplot(y);<br><span class="hljs-built_in">hold</span> on;fplot(y1);<br><span class="hljs-built_in">hold</span> on ;fplot(y2);<br></code></pre></td></tr></table></figure><figure><img src="/img/article/art6/2.png" alt="图 2 信号波形" /><figcaption aria-hidden="true">图 2 信号波形</figcaption></figure><p>再求一下函数驻点 <br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">dy = diff(y);<br>x1 = solve(dy);<br>ys = matlabFunction(y)<br>sol = ys(x1);<br></code></pre></td></tr></table></figure></p><p>然后打印出来：<br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">pretty(sol)<br>                   <span class="hljs-number">4</span>      <span class="hljs-number">3</span>                                       <span class="hljs-number">4</span>      <span class="hljs-number">3</span><br>- <span class="hljs-number">10</span> <span class="hljs-built_in">sin</span>(<span class="hljs-built_in">log</span>(root(z  + <span class="hljs-number">5</span> z  + <span class="hljs-number">5</span> z + <span class="hljs-number">1</span>, z, <span class="hljs-number">1</span>)) <span class="hljs-number">1</span><span class="hljs-built_in">i</span>) - <span class="hljs-built_in">sin</span>(<span class="hljs-built_in">log</span>(root(z  + <span class="hljs-number">5</span> z  + <span class="hljs-number">5</span> z + <span class="hljs-number">1</span>, z, <span class="hljs-number">1</span>)) <span class="hljs-number">2</span><span class="hljs-built_in">i</span>)<br></code></pre></td></tr></table></figure></p><p>输出结果如下： <br></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs matlab">pretty(sol)<br><br>/  #<span class="hljs-number">1</span> + #<span class="hljs-number">5</span>  \<br>|           |<br>|  #<span class="hljs-number">2</span> + #<span class="hljs-number">6</span>  |<br>|           |<br>|  #<span class="hljs-number">3</span> + #<span class="hljs-number">7</span>  |<br>|           |<br>|  #<span class="hljs-number">4</span> + #<span class="hljs-number">8</span>  |<br>|           |<br>| - #<span class="hljs-number">1</span> - #<span class="hljs-number">5</span> |<br>|           |<br>| - #<span class="hljs-number">2</span> - #<span class="hljs-number">6</span> |<br>|           |<br>| - #<span class="hljs-number">3</span> - #<span class="hljs-number">7</span> |<br>|           |<br>\ - #<span class="hljs-number">4</span> - #<span class="hljs-number">8</span> /<br><br>where<br><br>            /     /             /         /   <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">33</span>)   <span class="hljs-number">1</span> \ \ \   \<br>            |     | <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>) <span class="hljs-built_in">sqrt</span>| <span class="hljs-number">1</span> - <span class="hljs-built_in">sqrt</span>| - -------- - - | | |   |<br>            |     |             \         \       <span class="hljs-number">8</span>      <span class="hljs-number">8</span> / / |   |<br>   #<span class="hljs-number">1</span> == <span class="hljs-built_in">sin</span>| <span class="hljs-built_in">acos</span>| ------------------------------------------ | <span class="hljs-number">4</span> | <span class="hljs-number">10</span><br>            \     \                      <span class="hljs-number">2</span>                     /   /<br><br>            /     /             /         / <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">33</span>)   <span class="hljs-number">1</span> \ \ \   \<br>            |     | <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>) <span class="hljs-built_in">sqrt</span>| <span class="hljs-number">1</span> - <span class="hljs-built_in">sqrt</span>| -------- - - | | |   |<br>            |     |             \         \     <span class="hljs-number">8</span>      <span class="hljs-number">8</span> / / |   |<br>   #<span class="hljs-number">2</span> == <span class="hljs-built_in">sin</span>| <span class="hljs-built_in">acos</span>| ---------------------------------------- | <span class="hljs-number">4</span> | <span class="hljs-number">10</span><br>            \     \                     <span class="hljs-number">2</span>                    /   /<br><br>            /     /             /     /   <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">33</span>)   <span class="hljs-number">1</span> \     \ \   \<br>            |     | <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>) <span class="hljs-built_in">sqrt</span>| <span class="hljs-built_in">sqrt</span>| - -------- - - | + <span class="hljs-number">1</span> | |   |<br>            |     |             \     \       <span class="hljs-number">8</span>      <span class="hljs-number">8</span> /     / |   |<br>   #<span class="hljs-number">3</span> == <span class="hljs-built_in">sin</span>| <span class="hljs-built_in">acos</span>| ------------------------------------------ | <span class="hljs-number">4</span> | <span class="hljs-number">10</span><br>            \     \                      <span class="hljs-number">2</span>                     /   /<br><br>            /     /             /     / <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">33</span>)   <span class="hljs-number">1</span> \     \ \   \<br>            |     | <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>) <span class="hljs-built_in">sqrt</span>| <span class="hljs-built_in">sqrt</span>| -------- - - | + <span class="hljs-number">1</span> | |   |<br>            |     |             \     \     <span class="hljs-number">8</span>      <span class="hljs-number">8</span> /     / |   |<br>   #<span class="hljs-number">4</span> == <span class="hljs-built_in">sin</span>| <span class="hljs-built_in">acos</span>| ---------------------------------------- | <span class="hljs-number">4</span> | <span class="hljs-number">10</span><br>            \     \                     <span class="hljs-number">2</span>                    /   /<br><br>            /     /             /         /   <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">33</span>)   <span class="hljs-number">1</span> \ \ \   \<br>            |     | <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>) <span class="hljs-built_in">sqrt</span>| <span class="hljs-number">1</span> - <span class="hljs-built_in">sqrt</span>| - -------- - - | | |   |<br>            |     |             \         \       <span class="hljs-number">8</span>      <span class="hljs-number">8</span> / / |   |<br>   #<span class="hljs-number">5</span> == <span class="hljs-built_in">sin</span>| <span class="hljs-built_in">acos</span>| ------------------------------------------ | <span class="hljs-number">8</span> |<br>            \     \                      <span class="hljs-number">2</span>                     /   /<br><br>            /     /             /         / <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">33</span>)   <span class="hljs-number">1</span> \ \ \   \<br>            |     | <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>) <span class="hljs-built_in">sqrt</span>| <span class="hljs-number">1</span> - <span class="hljs-built_in">sqrt</span>| -------- - - | | |   |<br>            |     |             \         \     <span class="hljs-number">8</span>      <span class="hljs-number">8</span> / / |   |<br>   #<span class="hljs-number">6</span> == <span class="hljs-built_in">sin</span>| <span class="hljs-built_in">acos</span>| ---------------------------------------- | <span class="hljs-number">8</span> |<br>            \     \                     <span class="hljs-number">2</span>                    /   /<br><br>            /     /             /     /   <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">33</span>)   <span class="hljs-number">1</span> \     \ \   \<br>            |     | <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>) <span class="hljs-built_in">sqrt</span>| <span class="hljs-built_in">sqrt</span>| - -------- - - | + <span class="hljs-number">1</span> | |   |<br>            |     |             \     \       <span class="hljs-number">8</span>      <span class="hljs-number">8</span> /     / |   |<br>   #<span class="hljs-number">7</span> == <span class="hljs-built_in">sin</span>| <span class="hljs-built_in">acos</span>| ------------------------------------------ | <span class="hljs-number">8</span> |<br>            \     \                      <span class="hljs-number">2</span>                     /   /<br><br>            /     /             /     / <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">33</span>)   <span class="hljs-number">1</span> \     \ \   \<br>            |     | <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>) <span class="hljs-built_in">sqrt</span>| <span class="hljs-built_in">sqrt</span>| -------- - - | + <span class="hljs-number">1</span> | |   |<br>            |     |             \     \     <span class="hljs-number">8</span>      <span class="hljs-number">8</span> /     / |   |<br>   #<span class="hljs-number">8</span> == <span class="hljs-built_in">sin</span>| <span class="hljs-built_in">acos</span>| ---------------------------------------- | <span class="hljs-number">8</span> |<br>            \     \                     <span class="hljs-number">2</span>                    /   /<br></code></pre></td></tr></table></figure><p>乖乖，这是个什么东西？将其翻译成人话： <br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">d = double(sol)<br><br>d =<br><br>  <span class="hljs-number">-0.0000</span> <span class="hljs-number">-11.5372</span><span class="hljs-built_in">i</span><br> <span class="hljs-number">-10.1910</span> + <span class="hljs-number">0.0000</span><span class="hljs-built_in">i</span><br>  <span class="hljs-number">-0.0000</span> +<span class="hljs-number">11.5372</span><span class="hljs-built_in">i</span><br>  <span class="hljs-number">10.1910</span> + <span class="hljs-number">0.0000</span><span class="hljs-built_in">i</span><br>   <span class="hljs-number">0.0000</span> +<span class="hljs-number">11.5372</span><span class="hljs-built_in">i</span><br>  <span class="hljs-number">10.1910</span> + <span class="hljs-number">0.0000</span><span class="hljs-built_in">i</span><br>   <span class="hljs-number">0.0000</span> <span class="hljs-number">-11.5372</span><span class="hljs-built_in">i</span><br> <span class="hljs-number">-10.1910</span> + <span class="hljs-number">0.0000</span><span class="hljs-built_in">i</span><br></code></pre></td></tr></table></figure></p><p>看来，幅值是10.191 <br></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>MATLAB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乘法器优化——Booth编码的奥秘</title>
    <link href="/2023/01/14/%E4%B9%98%E6%B3%95%E5%99%A8%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94Booth%E7%BC%96%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/"/>
    <url>/2023/01/14/%E4%B9%98%E6%B3%95%E5%99%A8%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94Booth%E7%BC%96%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98/</url>
    
    <content type="html"><![CDATA[<h2 id="引子乘法器概论">引子：乘法器概论</h2><p>在整个数字集成电路的世界里，乘法器的速度优化是一个亘古不变的话题，因为乘法器是高性能微处理器中的关键部件，是进行高速计算特别是信号处理等方面应用时所必须的。对于现今普遍采用的阵列乘法器（arraymultiplier），它囊括了以下三个功能：产生部分积、累积部分积与最终相加，所以在进行乘法器速度优化时，我们可以从以下三个方面考虑：<br></p><ul><li>加快部分积的产生</li><li>减少部分积的数</li><li>加速部分积的加法操作</li></ul><figure><img src="/img/article/art5/1.png" alt="图 1 二进制阵列乘法器" /><figcaption aria-hidden="true">图 1 二进制阵列乘法器</figcaption></figure><p>本文主要在查阅有关资料的基础上，整理了<strong>布斯编码</strong>（BoothEncoding一种用来减少部分积数目的算法）与在此基础上提出的<strong>改进布斯编码</strong>（modifiedBooth’sencoding）的相关知识，并结合自己的理解，使用通俗易懂的语言进行阐述。<br></p><h2 id="booth编码">Booth编码</h2><h3 id="wikipedia定义">Wikipedia定义</h3><p>布斯编码可以减少部分积的数目，用来计算有符号乘法，提高乘法运算的速度。对于Booth编码，维基百科是这么说的：<br><img src="/img/article/art5/2.png" alt="图 2 Wikipedia定义" />这段详解已经胜过国内大多数教材的介绍，但相信这一大串数学符号也会劝退很多人，本文的目的就是通俗易懂，让小白也能看懂Booth编码。所以我又查阅资料，重新进行整理。<br> 锵！且听我娓娓道来~ <br></p><h3 id="工作原理">工作原理</h3><p>我们知道，乘法计算本质上就是加法运算，但当乘数中二进制1数量过多时，会出现大量繁杂的加法运算，而二进制0的存在可以降低运算次数，因为0和任何数相乘都为0，我们就无需再进行计算，就像下图中这样：<br> <img src="/img/article/art5/3.png" alt="图 3 简单乘法操作" /> <imgsrc="/img/article/art5/4.png" alt="图 4 繁杂乘法操作" />可以看出，相较于图4，图3中的计算由于乘数中0的个数较多，使得计算大大简化。<br>那么问题来了，是否存在这样一种编码方式，能够大大缩减乘数中二进制1的个数，进而简化运算？答案是肯定的，也就是我们将要介绍的Booth编码。<br> 其实早在小学时代，我们就学过这样的简便运算： <br> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">9x99=9x(100-1)=900-9=891<br></code></pre></td></tr></table></figure>将乘数“99”化为“100-1”，计算更为简单。类似的，在二进制补码乘法X<em>Y中，我们也可以采取相同的操作。对于乘数:<br> <span class="math display">\[Y=[0111\_1110]_补=2^6+2^5+2^4+2^3+2^2+2^1\]</span><br />我们采用另外一种相对简单的表示方式： <br> <span class="math display">\[[0111\_1110]_补=[1000\_0000]_补-[0000\_0010]_补，将其记为[1000\_00\overline10]（这里的\overline1是-1的缩写符号）\]</span> 此时X</em>Y可以表示为： <br> <span class="math display">\[X*Y=X*[0111\_1110]_补=X*([1000\_0000]_补-[0000\_0010]_补)=X*[1000\_0000]_补-X*[0000\_0010]_补\]</span> <br>采用这一形式，我们只需相加两个部分积（但这要求最终设计的加法器必须也能执行减法，否则需将减法-[0000_0010]补转换成补码加法+[1111_1110]补，这又会产生七个部分积，得不偿失）。这种形式的变换称为布斯编码（BoothEncode），它使部分积的数目至少可以缩减到原来的一半。部分积的减少意味着相加次数的减少，从而加快了运算速度并减少了面积。<br></p><h3 id="补码一位乘法">补码一位乘法</h3><p>下面先简要阐述Booth算法的基本流程： <br> 设<spanclass="math display">\[[X]_补=x_s·x_1·x_2···x_n,[Y]_补=y_s·y_1·y_2···y_n\]</span>其中<spanclass="math inline">\(x_s,y_s\)</span>均为符号位将符号位参与计算，运算数以补码表示且被乘数与部分积都取双符号位。<br></p><ul><li>被乘数和部分积均取两位符号位即变形码，乘数取一位符号位，并参与运算</li><li>乘数末尾增设附加位<span class="math inline">\(Y_{n+1}\)</span>，其初始值为0。 <span class="math inline">\(Y_n\)</span>和<spanclass="math inline">\(Y_{n+1}\)</span>构成各步运算的乘数判断位，按表所示方法进行操作</li><li>按补码移位规则：部分积为正(第一符号位为0)，右移时有效位最高位补0；部分积为负，右移时有效位最高位补1</li><li>按Booth乘法表算法进行到第n+1步，但第n+1步的部分积不再移位</li></ul><table align="center" border="2"><thead><tr><th colspan="4">Booth乘法表</th></tr></thead><tbody><tr><td>乘数位</td><td>编码位</td></tr><tr><td>00</td><td>0</td></tr><tr><td>01</td><td>+被乘数</td></tr><tr><td>10</td><td>-被乘数</td></tr><tr><td>11</td><td>0</td></tr></tbody></table><p>下面给出一个示例： <br> 设机器字长为5位，其中一位是符号位。且：<spanclass="math inline">\([X]_补=1.0101,[Y]_补=1.0011\)</span> <br> <imgsrc="/img/article/art5/5.png" alt="图 5 Booth乘法操作" /></p><h3 id="数学推导">数学推导</h3><p>对于只想浅探Booth编码的定义及工作原理的朋友，上述内容已足够清晰明了。但考虑到严谨性与实际应用，该部分给出部分数学上的推导以及更为详尽的说明。<br> 前面已经提到将乘数<spanclass="math inline">\(Y=[0111\_1110]_补\)</span>表示为<spanclass="math inline">\([1000\_00\overline10]\)</span>，这个转换不是一眼看出来的，怎样将其进行推广，使我们能够对任意的乘数都能进行类似的转换以化简运算呢？<br> 考虑有符号乘数： <span class="math display">\[Y=[y_{n-1}y_{n-2}···y_1y_0]_2\]</span></p><p><font color = #000000 size=2 face="宋体"><spanclass="math inline">\(Y=[y_{n-1}y_{n-2}···y_1y_0]_2\)</span></font> <br><font color = #000000 size=2 face="宋体"><spanclass="math inline">\((1)=-2^{n-1}·y_{n-1}+2^{n-2}·y_{n-2}+···+2^1·y_1+2^0·y_0+y_{-1}\)</span></font><br> <font color = #339933 size=2 face="宋体"><spanclass="math inline">\((2)=2^{n-1}·(y_{n-2}-y_{n-1})+2^{n-2}·(y_{n-3}-y_{n-2})+···+2^0·(y_{-1}-y_0)\)</span></font><br> <font color = #ff0000 size=2 face="宋体"><spanclass="math inline">\((3)=2^{n-2}·(y_{n-2}+y_{n-3}-2·y_{n-1})+2^{n-4}·(y_{n-4}+y_{n-5}-2·y_{n-3})+···+2^{0}·(y_{0}+y_{-1}-2·y_{1})\)</span></font><br> <font color = #ff0000 size=2 face="宋体"><spanclass="math inline">\((4)=\sum_{i=0}^{(N-1)/2}Y_i·4^i,(Y \in\{-2,-1,0,1,2\})\)</span></font> <br></p><p>定义<spanclass="math inline">\(Y_i=y_{i-2}-y_{i-1}\)</span>，考虑(2)式，对于二进制数<spanclass="math inline">\(Y,y_i \in \{0,1\}\)</span> ，从(2)式中可以看出：<br> <span class="math display">\[\left\{\begin{aligned}if &amp; &amp; y_{i+1}=y_i, &amp; &amp; then &amp; &amp; Y_i=0, \\if &amp; &amp; y_{i+1}&gt;y_i, &amp; &amp; then &amp; &amp; Y_i=1, \\if &amp; &amp; y_{i+1}&lt;y_i, &amp; &amp; then &amp; &amp; Y_i=-1.\end{aligned}\right.\]</span> 这构成了Booth编码的部分积选择表。 <br></p><table align="center" border="2"><thead><tr><th colspan="4">Booth乘法表</th></tr></thead><tbody><tr><td>乘数位</td><td>编码位</td></tr><tr><td>00</td><td>0</td></tr><tr><td>01</td><td>+被乘数</td></tr><tr><td>10</td><td>-被乘数</td></tr><tr><td>11</td><td>0</td></tr></tbody></table><p>定义<spanclass="math inline">\(Y_i=y_{i-2}+y_{i-3}-2·y_{n-1}\)</span>，考虑(3)式，对于二进制数<spanclass="math inline">\(Y,y_i \in \{0,1\}\)</span> ，从(3)式中可以看出：<br> <span class="math display">\[\left\{\begin{aligned}if &amp; &amp; y_{2i+1}=0 &amp; &amp; and &amp; &amp; y_{2i}+y_{2i-1}=0,&amp; &amp; then &amp; &amp; Y_i=0,  \\if &amp; &amp; y_{2i+1}=0 &amp; &amp; and &amp; &amp; y_{2i}+y_{2i-1}=1,&amp; &amp; then &amp; &amp; Y_i=1,  \\if &amp; &amp; y_{2i+1}=0 &amp; &amp; and &amp; &amp; y_{2i}+y_{2i-1}=2,&amp; &amp; then &amp; &amp; Y_i=2,  \\if &amp; &amp; y_{2i+1}=1 &amp; &amp; and &amp; &amp; y_{2i}+y_{2i-1}=0,&amp; &amp; then &amp; &amp; Y_i=-2, \\if &amp; &amp; y_{2i+1}=1 &amp; &amp; and &amp; &amp; y_{2i}+y_{2i-1}=1,&amp; &amp; then &amp; &amp; Y_i=-1, \\if &amp; &amp; y_{2i+1}=1 &amp; &amp; and &amp; &amp; y_{2i}+y_{2i-1}=2,&amp; &amp; then &amp; &amp; Y_i=0.\end{aligned}\right.\]</span> 这构成了改进Booth编码的部分积选择表。 <br></p><table align="center" border="2"><thead><tr><th colspan="4">改进Booth乘法表</th></tr></thead><tbody><tr><td>乘数位</td><td>编码位</td></tr><tr><td>000</td><td>0</td></tr><tr><td>001</td><td>+被乘数</td></tr><tr><td>010</td><td>+被乘数</td></tr><tr><td>011</td><td>+2×被乘数</td></tr><tr><td>100</td><td>-2×被乘数</td></tr><tr><td>101</td><td>-被乘数</td></tr><tr><td>110</td><td>-被乘数</td></tr><tr><td>111</td><td>0</td></tr></tbody></table><p>同时，我们还从（4）中看出，改进的Booth编码相当于把乘数变换为一个四进制形式，而不是通常的二进制形式。<br></p><p>读者在这里可能会有些疑惑：为什么已有了Booth编码，还要研究一个改进的Booth编码？<br></p><p>这是因为，如果使用Booth编码，乘数经编码后含二进制1的数量是不确定的，这会导致产生不确定的部分积数目，<em>在最坏情况下，一个8位的乘数经Booth编码后将含有4个部分积</em><br></p><p>考虑8位乘数在最坏情况下的输入：8位乘数1010_1010，经Booth编码后为<spanclass="math inline">\(\overline11\overline11\_\overline11\overline10=[0101\_0100]_补-[1010\_1010]_补\)</span>，Rabaey书上原文的说法是:<br></p><blockquote><p>“1010…10代表了最坏情况的乘数输入，因为它产生的部分积数目最多（为一半）”</p></blockquote><p>在这个例子中体现为减数<spanclass="math inline">\([1010\_1010]_补\)</span>在乘法运算时将会产生4个部分积。这里我有一点疑惑，按理说在乘法运算时将会产生7个部分积，被减数<spanclass="math inline">\([0101\_0100]_补\)</span>将会产生3个部分积，减数<spanclass="math inline">\([1010\_1010]_补\)</span>将会产生4个部分积。暂时保留这个疑惑，不求甚解了哈哈。<br></p><p>大小不同的部分积阵列对乘法器设计不合适，改进的Booth编码可以解决这个问题，正因如此，我们最常使用的是改进的Booth编码。<br></p><p>使用改进的Booth编码，乘数按三位一组进行划分，并相互重叠一位，每一组的三位按表改进的Booth编码表进行划分，（首先将乘数两两划分一组，那么编码的三位分别由当前组的两位加相邻低位组的最高位组成），编码过程由msb至lsb进行，编码后所形成的的部分积的数目等于乘数宽度的一半，是一个确定的数目。<br></p><p>最后给出一个改进Booth编码的示例： <br></p><blockquote><p>考虑前面提及的8位二进制数<spanclass="math inline">\([0111\_1110]_补\)</span>，按照改进Booth编码规则进行转换。首先将其两两划分一组，共分为四组：<spanclass="math inline">\(01、11、11、10\)</span>。接着将当前组的两位与相邻低位组的最高位进行组合，分为这样四组：<spanclass="math inline">\(011、111、111、100\)</span>，其中最后一组多出来的是附加位0。最后根据表11.2编码得到<spanclass="math inline">\(10(2×)、00(0×)、00(0×)、\overline10(-2×)\)</span>，组合在一起表示为<spanclass="math inline">\(1000\_00\overline10\)</span>.这与前面采用Booth编码得到的结果是一致的。</p></blockquote><h2 id="小结">小结</h2><p>本文通过对乘法器的速度优化进行引入，以通俗易懂的语言，介绍了Booth编码及在此基础上提出的改进Booth编码的原理与示例。<br></p><h2 id="后话">后话</h2><p>Booth编码是在本人学习计组、数集和硬件描述语言课程中反复碰到的一个概念，由于课程不做要求，一直没有太重视。但在数集的大作业中，其中一个选题又要求我们设计一个基于Booth编码的乘法器，虽然我没选这个（bushi）。因此我想要彻底弄懂这个概念，先后看了计组老师的PPT，啃了半天Rabaey的那本“圣经”，只觉头昏脑涨，查了很多资料才只敢说有一些浅显的了解，查阅资料加整理成markdown发布前后共耗费三天时间（markdown功底太差了，还得多练练）。由于本人能力与精力有限，文章难免存在错误与疏漏，大家还是有选择的阅读。<br></p><h2 id="参考文献">参考文献</h2><p>[1].维基百科 <br> [2].Rabaey. 数字集成电路——电路、系统与设计 <br>[3].<a href="https://www.zhihu.com/question/37637775">怎么理解Booth算法?- 知乎 (zhihu.com)</a> <br> [4].计组课程PPT 定点原码-补码乘法器</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>数字IC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>乘法器优化</tag>
      
      <tag>Booth编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文弄不懂MATLAB数据导入</title>
    <link href="/2022/12/12/%E4%B8%80%E6%96%87%E5%BC%84%E4%B8%8D%E6%87%82MATLAB%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5/"/>
    <url>/2022/12/12/%E4%B8%80%E6%96%87%E5%BC%84%E4%B8%8D%E6%87%82MATLAB%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="引子">引子</h3><p>今天在分析车道保持的训练数据时，想着之前也用过matlab分析过硅电池效率，这次也想着弄个图出来。一看log文件是csv格式，又懒得转成xlsx格式（虽然也就是两三步的事，但我今天还就和它杠上了，我非要用这个csv格式的文件）。<br>之前分析硅电池的时候，用的是<code>xlsread</code>命令导入xlsx文件，现在是csv文件，我先是想到了<code>load</code>命令，后来又再网上搜到了类似的<code>csvread</code>命令和一个我之前没遇到过的<code>importdata</code>命令。索性这次就好好捋一捋不同导入函数之间的爱恨情仇。（只总结了一些我认为比较常用的函数，更为详细的可查看官方文档。如果在之后的学习工作中我用到了其他的函数，我会继续添加上来。）<br> ### <code>xlsread</code>命令将文件变量导入到工作区中，一般<strong>针对电子表格</strong>文件。<br></p><blockquote><p>由于兼容性问题，不推荐使用这个函数，推荐使用readmatrix函数。 <br></p></blockquote><h3 id="csvread命令"><code>csvread</code>命令</h3><p>读取逗号分隔值 (CSV) 文件。 <br></p><blockquote><p>由于兼容性问题，不推荐使用这个函数，推荐使用readmatrix函数。 <br></p></blockquote><p>使用命令<code>M = csvread(filename,R1,C1,[R1 C1 R2 C2])</code>，仅读取行偏移量R1 和 R2 及列偏移量 C1 和 C2界定的范围。另一种定义范围的方法是使用电子表格表示法（例如'A1..B7'）而非 [0 0 6 1]。 <br>说人话：从csv文件中的第R1行开始读取到第R2行，第C1列开始读取到第C2列。例如：<br> 存在csv文件： <br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csv">02, 04, 06, 08<br>03, 06, 09, 12<br>05, 10, 15, 20<br>07, 14, 21, 28<br></code></pre></td></tr></table></figure> 使用命令： <br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">filename = <span class="hljs-string">&#x27;csvlist.csv&#x27;</span>;<br>M = csvread(filename)；<br>M = csvread(<span class="hljs-string">&#x27;csvlist.csv&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]);<br>M =<br><br>     <span class="hljs-number">3</span>     <span class="hljs-number">6</span>     <span class="hljs-number">9</span><br>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>    <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure></p><blockquote><p>注意： <br></p></blockquote><ul><li>与matlab数组下标从1开始不同，偏移量 R1=0、C1=0指定文件中的第一个值。 <br></li><li>我们可以使用<strong>电子表格表示法</strong>（例如 'A2..C3'）而非 [10 2 2]来指定读取范围。 <br></li></ul><h3 id="readmatrix命令"><code>readmatrix</code>命令</h3><p>readmatrix功能非常强大，可以从文件中读取矩阵。非常适合于以下两种文件：<br></p><ul><li>.txt、.dat 或 .csv（带分隔符的文本文件）</li><li>.xls、.xlsb、.xlsm、.xlsx、.xltm、.xltx 或 .ods（电子表格文件）</li></ul><h4 id="a-readmatrixfilename"><code>A = readmatrix(filename)</code></h4><p>使用命令<code>M = readmatrix('basic_matrix.xlsx')</code>将电子表格文件中的数值数据导入为矩阵，并命名为M。<br></p><h4id="a-readmatrixfilenameopts"><code>A = readmatrix(filename,opts)</code></h4><p>通过配置opts参数，可以使得在导入数据的时候满足更多个性化需求。 <br>例如，假如我有一个电子表格文件 airlinesmall_subset.xlsx 包含 1996 年至2008 年间多个工作表中的数据。每个工作表都包含给定年份的数据。使用命令：<br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">opts.Sheet = <span class="hljs-string">&#x27;2007&#x27;</span>;    <span class="hljs-comment">%指定读取名称为‘2007’的工作表中的数据</span><br>opts.SelectedVariableNames = [<span class="hljs-number">1</span>:<span class="hljs-number">5</span>];     <span class="hljs-comment">%指定读取第1列到第5列的变量</span><br>opts.DataRange = <span class="hljs-string">&#x27;2:11&#x27;</span>;    <span class="hljs-comment">%指定读取第2行到第11行的数据</span><br>M = readmatrix(<span class="hljs-string">&#x27;airlinesmall_subset.xlsx&#x27;</span>,opts)<br><span class="hljs-comment">%相当于使用命令：M = readmatrix(&#x27;airlinesmall_subset.xlsx&#x27;,&#x27;Sheet&#x27;,&#x27;2007&#x27;,&#x27;Range&#x27;,&#x27;A2:E11&#x27;)</span><br></code></pre></td></tr></table></figure></p><h3 id="imread命令"><code>imread</code>命令</h3><p>从<strong>图形文件</strong>读取图像。</p><h4 id="a-imreadfilename"><code>A = imread(filename)</code></h4><p>从 filename 指定的文件读取图像，并从文件内容推断出其格式。如果filename 为多图像文件，则 imread 读取该文件中的第一个图像。 <br></p><h3 id="audioread命令暂定"><code>audioread</code>命令（暂定）</h3><p>将文件变量导入到工作区中，一般<strong>针对音频</strong>文件</p><h3 id="load命令"><code>load</code>命令</h3><p>将文件变量导入到工作区中，一般<strong>针对matlab特有的格式文件</strong>，即.mat文件。 <br> 注意：<strong>load 命令在初始化变量时可能会执行 MAT文件中包含的代码。请避免对不受信任的 MAT 文件调用 load</strong> <br></p><h4 id="loadfilename"><code>load(filename)</code></h4><p>使用命令： <br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A = load(filename)       <span class="hljs-comment">%filename可以是.mat文件，也可以是ASCII文件（也叫文本文件即.txt文件）</span><br></code></pre></td></tr></table></figure></p><blockquote><p>注：ASCII文件指含有用标准ASCII字符集编码的字符的数据和文本文件，只含有字母、数字和常见的符号。这种文件在磁盘中存放时每个字符对应一个8bits的字节，用于存放对应的ASCII码。区别于按二进制的编码方式来存放文件的二进制文件。- 如果 filename 是 MAT 文件，则load(filename) 会将 MAT文件中的变量加载到 MATLAB® 工作区，A是结构数组。 - 如果 filename 是ASCII 文件，load(filename) 会创建一个包含该文件数据的双精度数组。 <br>我们还可以通过下面两条命令来指定导入的文件类型，而不管文件拓展名是什么：<br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A = load(<span class="hljs-number">123.</span>mat, ‘-ascii’)   <span class="hljs-comment">%尽管文件后缀为mat格式，我们仍将其作为ascii文件导入</span><br></code></pre></td></tr></table></figure> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A = load(<span class="hljs-number">456.</span>txt, ‘-mat’)   <span class="hljs-comment">%尽管文件后缀为txt格式，我们仍将其作为mat文件导入</span><br></code></pre></td></tr></table></figure></p></blockquote><blockquote><p>注：<strong>load函数的命令形式</strong>，使用命令’loadfilename’，省去了括号和文件名字符串外面的引号，除此之外我也不知道为什么要创造这个命令形式。<br></p><h3 id="importdata命令"><code>importdata</code>命令</h3><p>将数据导入到工作区中，可以导入各种类型的数据（如图片数据、数字、字符串等）、系统剪切板的数据等，函数的输入参数<code>delimiterIn</code>、<code>headerlinesIn</code>表示文件中的数据分隔符、以及我想从哪一行数据开始导入。<br> 附[mathworks官方importdata说明文档](https://ww2.mathworks.cn/help/matlab/ref/importdata.html#btldf1f-1)<br> <img src="/img/article/art4/pic1.png" alt="pic1" /></p></blockquote><h4id="importdatafilenamedelimiterinheaderlinesin"><code>importdata(filename,delimiterIn,headerlinesIn)</code></h4><p>说人话：使用参数<code>delimiterIn</code>告诉matlab我们文件中的数据分隔符是什么。使用参数<code>headerlinesIn</code>告诉matlab我想从哪里开始导入数据。如：<br> 我们使用文本编辑器创建一个带有列标题的称为 myfile01.txt 的空格分隔ASCII 文件。 <br> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">Day1  Day2  Day3  Day4  Day5  Day6  Day7<br>95.01 76.21 61.54 40.57  5.79 20.28  1.53<br>23.11 45.65 79.19 93.55 35.29 19.87 74.68<br>60.68  1.85 92.18 91.69 81.32 60.38 44.51<br>48.60 82.14 73.82 41.03  0.99 27.22 93.18<br>89.13 44.47 17.63 89.36 13.89 19.88 46.60<br></code></pre></td></tr></table></figure> 输入以下命令： <br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">filename = <span class="hljs-string">&#x27;myfile01.txt&#x27;</span>;<br>delimiterIn = <span class="hljs-string">&#x27; &#x27;</span>;<br>headerlinesIn = <span class="hljs-number">1</span>;<br>A = importdata(filename,delimiterIn,headerlinesIn);<br><span class="hljs-comment">% 也就是A = importdata(‘myfile01.txt’, ‘ ’, 1);</span><br><span class="hljs-comment">% 注意，第二个单引号内存在一个空格</span><br></code></pre></td></tr></table></figure>上面的命令告诉我们，我们要导入一个叫做’myfile01.txt’的文本文件，它是以空格作为分隔符，并且我们导入从<strong>headerlinesIn+1</strong>=2行开始的<strong>数值数据</strong>。 <br>获得一个结构体输出：<br> <img src="/img/article/art4/pic2.png"alt="pic2" /> 导出了从第headerlinesIn+1即第二行开始的数值数据作为struct中的data，第headerlinesIn行作为colheaders，第一行到第headerlinesIn行的数据作为textdata。在缺省headerlinesIn参数的情况下importdata函数将会在文件中检测该值。 <br></p><h4id="adelimiteroutheaderlinesout-importdata___"><code>[A,delimiterOut,headerlinesOut] = importdata(___)</code></h4><p>在<code>delimiterOut</code>中额外返回检测到的输入 ASCII文件中的分隔符，以及在<code>headerlinesOut</code>中返回检测到的标题行数。<br></p><h4id="a-importdata-pastespecial"><code>A = importdata('-pastespecial')</code></h4><p>将系统剪切板上的数据导入给A变量，这个数据不能是图片，因为系统剪切板复制的图片并没有存储在当前目录中。### <code>uiimport</code>命令（暂定）</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>MATLAB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录今日破防</title>
    <link href="/2022/12/07/%E8%AE%B0%E5%BD%95%E4%BB%8A%E6%97%A5%E7%A0%B4%E9%98%B2/"/>
    <url>/2022/12/07/%E8%AE%B0%E5%BD%95%E4%BB%8A%E6%97%A5%E7%A0%B4%E9%98%B2/</url>
    
    <content type="html"><![CDATA[<p>在将添加的两篇测试文章“text”、“text2”删除后，重新生成并部署网站后，发现文章依旧在网站端页面显示，我就意识到了事情的不简单。之所以添加这两篇测试文章，是因为我发现我新提交的文章“构建笔记系统”无法在页面显示，于是我就重新提交了两篇测试文章，发现每新提交一篇文章，网页上就会显示上一次提交的文章，这让我很疑惑。<img src="/img/article/art3/p1.png" alt="pic1" /> <imgsrc="/img/article/art3/p2.png" alt="pic2" />我首先留意到了这样一段warning: <br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">warning: <span class="hljs-keyword">in</span> the working copy of <span class="hljs-string">&#x27;archives/2022/12/index.html&#x27;</span>, LF will be replaced by CRLF the next time Git touches it<br></code></pre></td></tr></table></figure><p>在google后了解到，这是由于在跨平台操作下CR(CarriageReturn：回车，与LF(LineFeed：换行，)可能会产生冲突。详参考博文<ahref="https://blog.csdn.net/u012757419/article/details/105614028">git提示“warning:LF will be replaced byCRLF”的解决办法_青崖林夕的博客-CSDN博客</a>，此处不再赘述。由于我日常主力还是在Windows上进行，还是默认设置Git在提交时自动把回车（CR）和换行（LF）转换成换行（LF）。使用命令:<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#提交时转换为LF，检出时不转换</span><br>$ git config --global core.autocrlf <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>但我在提交新文章的时候仍然会产生这个warning，，， <br>然后我又输入了这样一条命令： <br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#提交时转换为LF，检出时不转换</span><br>$ git config core.autocrlf<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>再提交就不报warning了，很玄啊，<del>感觉在玩一种很新的东西</del><br>解决了这个warning，我闲着无事又刷新了网页，发现博客界面恢复正常了,给我整无语了。<br><img src="/img/article/art3/p3.png" alt="pic3" /></p><p>原来是从部署后到直接在页面显示出结果会有一定的延时，稍微等待一会就OK了，焯！建议大家以后提交博客后不要着急使用<code>hexo d</code>部署网站，先使用<code>hexo s</code>启用服务预览看一看页面是否正常后再部署，然后稍微<strong>耐心等待</strong>一会。<br>好了，折腾了将近两个小时，整了这么一出闹剧，下午还得复习复习半导体器件，估计明天就期中考试了。<br>啥都不会，救，，，</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网页部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构建笔记系统</title>
    <link href="/2022/12/06/%E6%9E%84%E5%BB%BA%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/12/06/%E6%9E%84%E5%BB%BA%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>此文章是对B站UP主田浅浅发布的<ahref="https://www.bilibili.com/video/BV12N4y1c7KW/?spm_id_from=333.1007.top_right_bar_window_history.content.click">构建笔记系统</a>的一些整理，方便以后回顾。</p><h2 id="笔记的功能">笔记的功能</h2><p>以不同的应用场景为例，涉及到笔记不同的功能：<strong>记录功能</strong>、<strong>理解功能</strong>、<strong>压缩功能</strong>。记住，学习的最终目的是让知识进入到脑子里，不是写给别人看的，可以不用太过追求美观。<br></p><h3 id="记录功能求全面">记录功能（求全面）</h3><p>在听讲座时，时间紧张，以扎住关键信息为主，体现以<strong>收集信息</strong>为目的的记录功能。<br></p><h3 id="理解功能读清晰">理解功能（读清晰）</h3><p>在阅读教材时，体现以<strong>整理加工信息</strong>为目的的理解功能，不要浪费时间抄书本上已有的信息。只有书上没有，需要补充的信息如新的发现、科技创新或将几本书籍的内容整合在一起时。可单独建立一个文档或一个笔记本，把不同来源的资料归一整合。<br>处理加工已经收集到的信息，变成自己能够理解的东西，分为两个步骤：<br></p><h4 id="信息管理">信息管理</h4><p>找出不同段落之间的内在联系，是宏观上的信息管理；找出不同句子和词之间的联系，是微观上的信息管理。</p><h4 id="知识管理">知识管理</h4><p>它表征了我们学习时对知识的掌握程度。将接触到的知识<strong>进行分类</strong>如：重点，难点，是否掌握，是否牢固，是否需要针对性做题复习等等。<br>可使用不同颜色标注，示例：<br><font color = #66FF66 size=5 face="宋体">【难点+没懂】!!!</font>意思是这里很难并且我还没弄懂。 <br><font color = #ff0000 size=5 face="宋体">【难点+懂了】难句子</font>意思是这个地方虽然很难，但我已经掌握了，只需要稍后去复习。 <br><font color = #66ccff size=5 face="宋体">【重点、概括性】句子</font>很重要，需要加强理解。 <br><font color = #ffd700 size=5 face="宋体">【重要概念】名词</font>标注一些重要的名词。 <br></p><h3 id="压缩功能厚书读薄">压缩功能（厚书读薄）</h3><p><strong>建立在理解和记忆的基础上</strong>，把信息概括成一个一个的组块，关键在于把句子压缩到<strong>尽可能简洁</strong><br>由于大脑容量有限，无法准确记忆每一个句子，我们可以使用关键词概括一整段的资料。极度压缩信息，比如思维导图，形成一个完整的框架。复习时大脑进行知识闪回，知识流扩散，重组。<br>可以记在笔记本上，亦可以直接写在书本上（如政治课）。这一步可以用一些速记符号，记忆口诀、联想法和记忆迷宫等方式</p><h3 id="检测功能知识入脑">检测功能（知识入脑）</h3><p>学习的目的是记忆、掌握知识，笔记就是用来复习检验，确保真正记忆理解了信息。<br>利用第三步压缩的框架，回忆整个知识点。当你把整个框架都从单个的概括压缩性的词还原成书本上的文段和句子后，进行<strong>查漏补缺</strong>，并做好对应的标记。</p><p><strong>一句话概括：理解→化繁为简→记忆→化简为繁→查漏补缺。把书从厚读薄，再从薄读厚</strong></p>]]></content>
    
    
    <categories>
      
      <category>涉猎集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>序章</title>
    <link href="/2022/12/05/%E5%BA%8F%E7%AB%A0/"/>
    <url>/2022/12/05/%E5%BA%8F%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="序">序</h2><p>GitHub IO, <strong>我来啦!</strong>折腾了一天，终于搭建好了属于自己的博客！<br><del>以后就可以在这个小窝安心地生产垃圾啦</del><br>咳咳，我要记录想法、学习心得以供将来参考<del>顺便有事没事倾诉一下苦水、发发牢骚</del><br></p><h2 id="小小记录一下几个命令">小小记录一下几个命令</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server / 常简写为hexo s<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate / 常简写为hexo g<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy / 常简写为hexo g<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>絮言碎笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>遐想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
